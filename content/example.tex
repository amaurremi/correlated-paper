\section{Motivating Example}
  \label{sec:MotivatingExample}
  
In this section, we illustrate our approach using a small motivating example that
shows how our technique can be used to improve the precision of taint analysis.
A taint analysis is a specialized dataflow analysis for computing how string values
may flow from ``sources'', which are typically statements that read untrusted input, 
to ``sinks'', which are typically security-sensitive
operations such as calls to 
a database. In previous research \cite{DBLP:conf/issta/GuarnieriPTDTB11,DBLP:conf/pldi/ArztRFBBKTOM14}, 
taint analysis algorithms have been formulated as IFDS problems.     
  
\input{figures/fig-examplesupergraph}
  
Figure~\ref{list:ccexample} shows a small Java program that we will use to illustrate
how our technique can improve the precision of a simple taint analysis. The program
declares a class \code{A} with a subclass \code{B},  where \code{A} defines methods 
\code{foo()} and \code{bar()} that are overridden in \code{B}.  In order to keep the 
example small and self-contained, it is assumed  that secret values are created by 
an unspecified function \code{secret()}, which is called in method \code{A.foo()} on 
line~\ref{line:Afoo}. Furthermore, it is assumed that any write to the standard output 
stream via calls \code{System.out.println()} such as the one in method \code{B.bar()} 
on line~\ref{line:Bbar} is a security-sensitive operation. Depending on the number of 
arguments passed to the program, the \code{main()} method of the example program creates 
either an \code{A}-object or a \code{B}-object on line~\ref{line:createObject}. The 
program then calls \code{foo()} on this object on line~\ref{line:callfoo}, which is 
followed by a call to \code{bar()} on the same object on line~\ref{line:callbar}.  
 
The specific question that we would like to answer for the example program of
Figure~\ref{list:ccexample} is the following: Is it possible for the untrusted value 
that is read on line~\ref{line:Afoo} to flow to the print statement on line~\ref{line:Bbar}? 
%
To determine whether such a flow of tainted data is possible, consider the control-flow
supergraph for the example program that is shown in Figure~\ref{fig:examplesupergraph}.
 The nodes in this graph correspond to statements, method entry points (start nodes) and 
method exit points (end nodes). Note that for each method call, the graph contains a 
distinct call-node and a return-node. Edges in the graph reflect intraprocedural control flow, 
flow of control from a caller to a callee (edges from call-nodes to start-nodes), or
flow of control from a callee back to a caller (edges from end-nodes to return-nodes). 

In the case of our example, the control flow within each of the methods is straightforward and
all interesting issues arise from interprocedural control flow. In particular,
note that, since the variable \code{a} may point to either an \code{A}-object or a \code{B}-object, 
the call on line~\ref{line:callfoo} may dispatch to either \code{A.foo()} or to \code{B.foo()},
and this is reflected by edges  
  from the node labeled $\highlight{\code{call}_\code{foo}}{greyblue}$ to the nodes labeled
  $\highlight{\code{start}_\code{A.foo()}}{bisque}$ and $\highlight{\code{start}_\code{B.foo()}}{lightsalmonpink}$
and by edges
  from the nodes labeled $\highlight{\code{end}_\code{A.foo}}{bisque}$ and $\highlight{\code{end}_\code{B.foo}}{lightsalmonpink}$ 
  to the node labeled  $\highlight{\code{return}_\code{foo}}{greyblue}$.  
Similarly, there are edges from the node labeled $\highlight{\code{call}_\code{bar}}{greyblue}$ to the nodes 
$\highlight{\code{start}_\code{A.bar()}}{bisque}$ and $\highlight{\code{start}_\code{B.bar()}}{lightsalmonpink}$, and 
edges
  from the nodes labeled $\highlight{\code{end}_\code{A.bar}}{bisque}$ and $\highlight{\code{end}_\code{B.bar}}{lightsalmonpink}$ 
  to the node labeled  $\highlight{\code{return}_\code{bar}}{greyblue}$. 
 
Informally speaking, an IFDS-based dataflow analysis propagates dataflow facts along the edges
of a control flow supergraph such as the one in Figure~\ref{fig:examplesupergraph}. The
IFDS algorithm was carefully designed to avoid infeasible paths that may arise in the
presence of multiple calls to the same method. However, in this example all methods are
called in exactly one place, so IFDS is unable to eliminate dataflow along any of the
paths shown in the figure. As a result, IFDS-based taint analysis algorithms such as
\cite{DBLP:conf/issta/GuarnieriPTDTB11,DBLP:conf/pldi/ArztRFBBKTOM14} would report 
that the secret value read on line~\ref{line:Afoo}
might flow to the print statement on line~\ref{line:Bbar}. 

As we discussed previously, the calls to \code{foo()} and \code{bar()} may dispatch
to different implementations of these methods in classes \code{A} and \code{B}, 
because the variable \code{a} that serves as the receiver for the call may be bound to
 objects of type \code{A} or type \code{B} at run time. 
However, consider the fact that the methods \code{foo()} and \code{bar()} are invoked
on \textit{the same object}. This means that the behaviors of the two method calls
are \textit{correlated}: if the call to \code{foo()} dispatches to \code{A.foo()},
then the call to \code{bar()} must dispatch to \code{A.bar()}, and if the call
to \code{foo()} dispatches to \code{B.foo()}, then the call to \code{bar()} must 
dispatch to \code{B.bar()}.  Consequently, paths such as the one highlighted in
Figure~\ref{fig:examplesupergraph} where the call to \code{foo()} dispatches 
to \code{A.foo()} and where the call to \code{bar()} dispatches to \code{B.bar()}
are infeasible.  

The main contribution of this paper is an algorithm for transforming an IFDS problem 
into an IDE problem that expresses the feasibility of paths
in light of correlated calls.
Informally speaking, our approach associates with each edge in an
interprocedural CFG a function that records the types of 
variables that are used as the receiver of correlated method calls. Paths that 
are composed of edges in which the same receiver expression has different types
are infeasible, and the propagation of dataflow facts along such paths is
prevented. Applying our technique to an IFDS-based taint analysis would enable
the resulting IDE-based taint analysis to determine that no secret value can flow from
line~\ref{line:Afoo} to the print statement on line~\ref{line:Bbar}. 

In summary, the example discussed in this section shows how the precision of 
IFDS-based taint analysis can be improved by taking into account how paths
become infeasible in the presence of correlated calls. In particular, we have
shown how a false positive reported by a standard IFDS-based algorithm is eliminated.
While the discussion in this section has focused on the specific problem of taint analysis,
we would like to emphasize that our technique generally applies to \textit{any}
dataflow analysis problem that can be expressed in the IFDS framework. This includes
many common analysis tasks such as \TODO{please add a few examples + citations} 


 
  

