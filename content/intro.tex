\section{Introduction}

Data-flow analysis computes an approximation of how values may flow  
through a program, and has applications in compiler optimization, 
programming tools, and computer security, and many other areas.
Data-flow analyses operate on \textit{control-flow graphs} (CFGs)
\mtodo{If we introduce this abbreviation, should we replace the uses of
``control-flow graph'' with ``CFG'' in the paper?}
that model 
the order in which the instructions of a program are executed. This is
typically done by associating \textit{flow functions} that represent how 
data is propagated with the edges of the control-flow graph.  A 
\textit{confluence operator} specifies how the data facts that have been 
computed along different paths should be merged when the paths join.

Since a control-flow graph is an over-approximation of the possible flows 
of control in concrete executions of a program, it may contain \textit{infeasible} 
paths that cannot occur at runtime. The precision of a data-flow analysis algorithm
depends critically on its ability to detect and disregard such infeasible paths.
The popular \textit{Interprocedural Finite Distributive Subset} (IFDS) algorithm 
by  Reps, Horwitz, and Sagiv \cite{reps1995precise} is a general data-flow analysis
algorithm for computing solutions to standard finite distributive data-flow problems such 
as reaching definitions, available expressions, and taint analysis.
\mtodo{We should define somewhere what taint analysis is, since it's currently
commented out.}
A distinguishing 
characteristic of IFDS is that it avoids infeasible interprocedural paths in which calls 
and returns to/from functions are not properly matched. Sagiv, Reps, and Horwitz
also presented the \textit{Interprocedural Distributive Environment} (IDE) algorithm
\cite{sagiv1996precise} that similarly only considers properly matched call/return
edges, but that supports a broader range of dataflow problems by expanding the 
domain of flow functions to \textit{environments} that go beyond the data-flow facts 
considered by IFDS.

This paper presents an approach to dataflow analysis that avoids a type
of infeasible path that arises in object-oriented programs when two or more
methods are dynamically dispatched on the same receiver object. In such cases, if the
method calls are polymorphic (i.e., if they dispatch to different method definitions 
depending on the type of the receiver expression at run time), then their dispatch 
behaviors will be correlated. A recent paper \cite{DBLP:journals/scp/Tip15} identified
this problem but did not present a concrete solution or algorithm, and we are not aware 
of any existing dataflow analysis that is capable of avoiding infeasible paths that arise 
in the presence of correlated method calls.

\input{figures/fig-transformation}

The approach taken in our work is to transform a standard IFDS problem into an
IDE problem that precisely accounts for infeasible paths due to correlated calls. 
The results of this IDE problem can be mapped back to the dataflow domain of the 
original IFDS problem.

We present a formalization of the transformation and prove its correctness
as follows. First, we derive an ``Equivalence IDE problem''
\mtodo{The IDE paper already states that each IFDS problem can be solved with IDE.
I wonder if this sounds like the equivalence transformation was our contribution.
We just use the equivalence transformation to explain the CC transformation, and for the
proofs.
}
from the original 
IFDS problem by associating the identity environment functions with all edges,
and show that the solution to this Equivalence IDE problem can be mapped back
to the solution of the original IFDS problem. Then, we derive a ``Correlated Calls 
IDE Problem'' from the original IFDS problem and show how a solution to this problem 
can be mapped to the solution to the original IFDS problem, but also how a
more precise IFDS result can be derived from it. 
\otodo{Do we need to mention the imprecise map from the CC-IDE result to the IFDS result? It
doesn't really seem relevant, and could be confusing.}
We also show that the correlated-calls analysis is sound, i.e., that it never considers concrete execution paths as infeasible.
This is illustrated schematically
in Figure~\ref{fig:transformations}%
\footnote{ 
  The labels $\result$, $\backEq$, $\backCC$, $\transEq$, and $\transCC$ on edges in 
  Figure~\ref{fig:transformations} reflect a number of mappings and projections 
  that will be defined in Section~\TODO{ref} and that can be ignored here.
}.  
\ftodo{would it make sense to add an edge in Figure~\ref{fig:transformations} from the IFDS problem to the IFDS result?}

We implemented the correlated-calls transformation and the IDE algorithm in Scala,
on top of the WALA framework for static analysis of JVM bytecode~\cite{fink2012wala}.
We also report on preliminary experiments in which our correlated-calls transformation
is applied to an IFDS formulation of a simple taint analysis. Our results show that
solving the resulting IDE problem avoids infeasible paths due to correlated calls as
expected.

In summary, the contributions of this paper are as follows:
\begin{itemize}
  \item
    We present a general approach for transforming IFDS problems into corresponding
    IDE problems that avoid infeasible paths due to correlated method calls and
    prove its correctness. 
  \item
    We implemented the approach in Scala, on top of the WALA program analysis framework
    and report on preliminary experiments. 
\end{itemize}

The remainder of this paper is organized as follows.
%
Section~\ref{sec:MotivatingExample} presents a motivating example.
%
Section~\ref{sec:bg} reviews the IFDS and IDE algorithms.
%
Section~\ref{sec:ccdatastr} presents the correlated-calls transformation
and a proof of its correctness.
%
The implementation of our approach and preliminary experiments are discussed
in Section~\ref{chapter:eval}.
%
Related work is discussed in Section~\TODO{ref}.
%
Finally, conclusions and directions for future work are presented in Section~\TODO{ref}.
 
 
\commentout{
Static program analysis aims to discover properties of computer programs without running them.
Static analysis has applications in compiler optimization, development of programming tools, and computer security, among others.
As an example, we might want to analyze a program to know which variables are constants. 
We could then write a compiler optimization that ensures that the values of those variables are computed only once.
Alternatively, we could use the information about constant variables in an integrated development environment; for instance, to notify the user when an if-expression executes only one of its branches because its test condition has a constant value.

There are demonstrable limits on what information we can obtain about a program without running it.
Rice's theorem states that verifying any non-trivial property of a program is an undecidable problem~\cite{rice1953classes}. However, it is sometimes possible to design an algorithm that \textit{over}- or \textit{underapproximates} the solution that we are seeking.

\textit{Data-flow analysis} is an area of program analysis whose goal is to compute approximations of certain information (for example, which variables must be constants) for each program point. 

Other examples of data-flow analyses are \textit{reaching definitions} (finding out up to which instruction a given assignment of a variable must be valid) and \textit{available expressions} (retrieving the expressions in the program that do not need to be recomputed at a given program point).

Another example of a data-flow analysis is \textit{taint analysis}~\cite{tripp2009taj}. Taint analysis discovers if ``secret'' values, like passwords or other confidential user information, can leak to an external observer. Methods that generate secret values, e.g. those that read user input, are called \textit{sources}. Methods that can leak information, e.g. those that write data to a file or send data through a network, are called \textit{sinks}. The goal of taint analysis is to find out whether data can propagate from sources to sinks.

An important property of a data-flow analysis is \textit{precision}.
Precision reflects how closely a data-flow-analysis result over- or underapproximates the information we are interested in. In the case of taint analysis, let $T$ be the number of sinks that the analysis considers to leak secret information, and $R$ the real number of potential information leaks. The smaller the difference between $T$ and $R$, the greater the precision of the taint analysis.

Data-flow analyses operate on \textit{control-flow graphs} that model the order in which the instructions of a program are executed.
A data-flow-analysis problem defines \textit{flow functions} that represent how data is propagated along the edges of the control-flow graph. The \textit{confluence operator} specifies how the data that has been computed along different paths should be merged when the paths join.

Since a control-flow graph is an overapproximation of the possible flows of control in concrete executions of a program, the graph may contain \textit{infeasible} paths that cannot occur at runtime.

One way to improve the precision of a data-flow analysis is to detect and eliminate infeasible paths.

Our goal is to improve the precision of solutions to problems that can be solved by the \textit{Inter-procedural Finite Distributive Subset} (IFDS) algorithm~\cite{reps1995precise}.
The IFDS algorithm is a general data-flow algorithm that can compute solutions to various data-flow problems, like reaching definitions, available expressions, and taint analysis.

We improve the precision of IFDS problem solutions by eliminating infeasible paths that occur in object-oriented programs in the presence of \textit{correlated method calls}~--- polymorphic calls that are invoked on the same object~\cite{DBLP:journals/scp/Tip15}.
}

