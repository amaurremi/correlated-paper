\section{Introduction}
\otodo{This section should be shrunk a lot (not completely deleted)}
\begin{odelete}
Static program analysis aims to discover properties of computer programs without running them.
Static analysis has applications in compiler optimization, development of programming tools, and computer security, among others.
As an example, we might want to analyze a program to know which variables are constants. 
We could then write a compiler optimization that ensures that the values of those variables are computed only once.
Alternatively, we could use the information about constant variables in an integrated development environment; for instance, to notify the user when an if-expression executes only one of its branches because its test condition has a constant value.

There are demonstrable limits on what information we can obtain about a program without running it.
Rice's theorem states that verifying any non-trivial property of a program is an undecidable problem~\cite{rice1953classes}. However, it is sometimes possible to design an algorithm that \textit{over}- or \textit{underapproximates} the solution that we are seeking.

\textit{Data-flow analysis} is an area of program analysis whose goal is to compute approximations of certain information (for example, which variables must be constants) for each program point. 

Other examples of data-flow analyses are \textit{reaching definitions} (finding out up to which instruction a given assignment of a variable must be valid) and \textit{available expressions} (retrieving the expressions in the program that do not need to be recomputed at a given program point).

Another example of a data-flow analysis is \textit{taint analysis}~\cite{tripp2009taj}. Taint analysis discovers if ``secret'' values, like passwords or other confidential user information, can leak to an external observer. Methods that generate secret values, e.g. those that read user input, are called \textit{sources}. Methods that can leak information, e.g. those that write data to a file or send data through a network, are called \textit{sinks}. The goal of taint analysis is to find out whether data can propagate from sources to sinks.

An important property of a data-flow analysis is \textit{precision}.
Precision reflects how closely a data-flow-analysis result over- or underapproximates the information we are interested in. In the case of taint analysis, let $T$ be the number of sinks that the analysis considers to leak secret information, and $R$ the real number of potential information leaks. The smaller the difference between $T$ and $R$, the greater the precision of the taint analysis.

Data-flow analyses operate on \textit{control-flow graphs} that model the order in which the instructions of a program are executed.
A data-flow-analysis problem defines \textit{flow functions} that represent how data is propagated along the edges of the control-flow graph. The \textit{confluence operator} specifies how the data that has been computed along different paths should be merged when the paths join.

Since a control-flow graph is an overapproximation of the possible flows of control in concrete executions of a program, the graph may contain \textit{infeasible} paths that cannot occur at runtime.

One way to improve the precision of a data-flow analysis is to detect and eliminate infeasible paths.

Our goal is to improve the precision of solutions to problems that can be solved by the \textit{Inter-procedural Finite Distributive Subset} (IFDS) algorithm~\cite{reps1995precise}.
The IFDS algorithm is a general data-flow algorithm that can compute solutions to various data-flow problems, like reaching definitions, available expressions, and taint analysis.

We improve the precision of IFDS problem solutions by eliminating infeasible paths that occur in object-oriented programs in the presence of \textit{correlated method calls}~--- polymorphic calls that are invoked on the same object~\cite{DBLP:journals/scp/Tip15}.
\end{odelete}

\section{Motivating Example}

Consider a call site~$r.m()$ in an object-oriented programming language, where the variable~$r$ is the \textit{receiver} variable of the call site and $m$ is the name of the invoked method\footnote{We assume an internal representation of the program in which for each call site $e_r.m()$, the expression~$e_r$ has been evaluated to the variable~$r$.}. In the rest of the paper, we use the general term \textit{receiver} to mean a receiver variable.
At runtime, the actual method that will be invoked by the call site depends on the runtime type of the object referenced by $r$. If the call site $r.m()$ can be associated with more than one method at compile time, we will say that the call site is \textit{polymorphic}.

For example, in Listing~\ref{list:ccexample}, it is not possible to infer statically whether the runtime type of the variable \verb'a' in the \texttt{main} method is \verb'A' or \verb'B'.
The call \verb'a.foo()' can be dispatched to either \verb'A.foo' or \verb'B.foo', and \verb'a.bar(v)' can be dispatched to either \verb'A.bar' or \verb'B.bar'.
A concrete execution path for the main method might therefore go through \verb'A.foo' and \verb'A.bar', or through \verb'B.foo' and \verb'B.bar'.
However, there cannot be an execution path through \verb'A.foo' and \verb'B.bar' or through \verb'B.foo' and \verb'A.bar'.

\begin{figure}
  \centering
  \begin{minipage}{\textwidth}
    \inputMinted{java}{ccexample.java}
  \end{minipage}
  \caption{Example program containing correlated calls}
  \label{list:ccexample}
\end{figure}

We call the invocations to methods \verb'foo' and \verb'bar' \textit{correlated}.
More generally, correlated calls occur when more than one polymorphic call is invoked on the same receiver variable.

Suppose we wanted to perform a taint analysis on the program in Listing~\ref{list:ccexample}.
Most dataflow-analysis algorithms, including IFDS, would conservatively assume that the call \verb'a.bar' could be dispatched to both \verb'A.bar' and \verb'B.bar', independently of what \verb'a.foo' had been dispatched to in the previous line.

As a result, 
such an analysis would consider a path through \verb'A.foo' and \verb'B.bar' feasible. This means that the variable \verb'v' would be considered secret. We would conclude that a secret value is passed to \verb'B.bar' and printed to the user. In other words, we would consider the program to leak secret information, which it does not do in any concrete execution.

Our technique for improving the precision of an IFDS result is based on transforming the original IFDS problem into a more expressive \textit{Inter-procedural Distributive Environment} (IDE) problem. IDE problems can be solved with the IDE algorithm which is a generalization of IFDS~\cite{sagiv1996precise}. The IDE algorithm can, for instance, solve certain versions of the constant propagation problem that IFDS cannot.

To improve the precision of IFDS results, given an IFDS problem $P$, we convert it into an IDE problem $Q$ that accounts for correlated calls. We then use the IDE algorithm to obtain a solution to $Q$. Finally, we convert the IDE result into a IFDS result. In the presence of correlated calls, the obtained IFDS result can be more precise than the solution that the IFDS algorithm would compute for $P$.

The goal of the correlated-calls analysis presented in this work is to modify the output of an IFDS analysis to account for correlated calls. Specifically, the correlated-calls analysis improves the precision of IFDS problem results by eliminating infeasible execution paths caused by correlated calls. This is done by converting the input-IFDS problem to an IDE problem that detects infeasible paths, and converting the IDE result back to a more precise IFDS result.

The contributions of this work are:
\begin{itemize}
  \item A transformation from IFDS to IDE problems that considers correlated calls.
  \item An implementation in Scala of the correlated-calls transformation and the IDE algorithm which is based on the WALA framework for static analysis on Java bytecode~\cite{fink2012wala}.
\end{itemize}\mtodo{Reference the figure here.}

\begin{figure}
  \centering
    \tikzset{
  ashadow/.style={opacity=.25, shadow xshift=0.07, shadow yshift=-0.07},
}
  \tikzstyle{problem}=[fill=greyblue,text width=2.3cm,rounded corners,font=\small,text=charcoal,drop shadow={ashadow, color=greyblue}]
  \tikzstyle{result}=[fill=bisque,text width=1.8cm,rounded corners,font=\small,text=charcoal,drop shadow={ashadow, color=greyblue}]
\begin{tikzpicture}
    \node [problem] (ifds) {IFDS problem};
    \node [problem] (equiv) [above right=0.9cm and .7\dist of ifds.east] {Equivalent IDE problem};
    \node [problem] (ccide)[below=3cm of equiv.west, anchor=west] {Correlated-calls IDE problem};
    \node [result] (equivres) [right=\dist of equiv.east] {Equivalence-IDE result};
    \node [result] (ccres) [below=3cm of equivres.west,anchor=west] {Correlated-calls result};
    \node [result] (ifdsres) [right=\dist of equivres.east] {IFDS result};
    \node [result] (improved) [right=\dist of ccres.east] {Improved IFDS result};
    \path[->] (equivres) edge node[above]{$\backEq$} (ifdsres);
    \path[->] (ccres) edge node[above] {$\backCC$} (improved);
    \path[->] (ccres) edge[out=30,in=240] node[above] {$\backEq$} (ifdsres);
    \path[->] (ifds) edge[out=40,in=190] node[above] {$\transEq$} (equiv);
    \path[->] (ifds) edge[out=-60,in=165] node[above] {$\transCC$} (ccide);
    \path[->] (equiv) edge node[above]{$\result$} (equivres);
    \path[->] (ccide) edge node[above]{$\result$} (ccres);
\end{tikzpicture}
  \caption{Transformations between IFDS and IDE problems and their results}%
  \label{fig:transformations}%
\end{figure}

  We prove that the solution to an IDE problem that considers correlated calls is more precise than the solution to the original IFDS problem.
  We also show that the correlated-calls analysis is sound, i.e. that it never considers concrete execution paths as infeasible.\mtodo{As discussed on the phone, we want to talk more about the results here.}
 
 Finally, we evaluate the effectiveness of the correlated-calls analysis using an implementation of taint analysis as the source IFDS problem.

The remainder of this paper is organized as follows. In the next section, we describe the IFDS and IDE analyses in detail. In Section~\ref{chapter:cca} we present the correlated-calls analysis as a transformation of IFDS problems into a special kind of IDE problem. Section~\ref{sec:ccdatastr} describes an efficient representation of the data structures that are required to define a correlated-calls IDE transformation.
In Section~\ref{chapter:eval} we address some implementation aspects of the correlated-calls analysis and present an evaluation of its results. Section~\ref{chapter:concl} contains concluding remarks. The proofs for the lemmas in the paper are provided in the Appendix.\mtodo{Reference appendix like this?}
