\section{Background}\label{sec:bg}
%The purpose of the correlated-calls analysis is to solve IFDS problems more precisely than using the standard IFDS algorithm by ruling out some infeasible paths. The correlated-calls analysis works by transforming an IFDS problem to an IDE problem, solving the IDE problem, and transforming the IDE result to a solution to the original IFDS problem. 
This section defines basic terminology and presents the IFDS and IDE algorithms.

\subsection{Terminology and Notation}
%We will start by introducing several concepts used by the IFDS and IDE analyses.
The \textit{control-flow graph} of a procedure is a directed graph whose nodes are instructions, and which contains an edge from $n_1$ to $n_2$ whenever
$n_2$ may execute immediately after $n_1$. A control-flow graph has a distinguished \textit{start node} \textsf{start}$_p$ and \textit{end node} \textsf{end}$_p$.
%and edges represent transfer of control between the instructions during an execution of the program. 
%A control-flow graph has a unique start node, $\startmain$, which is the node corresponding to the program entrypoint.
%An \textit{intra-procedural} path is a path in a control-flow graph whose nodes are in the same procedure. By contrast, an \textit{inter-procedural path} is one that contains nodes from different procedures. 
The \textit{control-flow supergraph} of a program contains the control-flow graphs of all of the procedures as
subgraphs. In addition, for each call instruction $c$, the supergraph contains a \textit{call-to-start} edge to the start node of every procedure that
may be called from $c$, and an \textit{end-to-return} edge from the end node of the procedure back to the call instruction.
\otodo{do we really need to extra "return nodes" that the IFDS/IDE papers add?}
%is a control-flow graph
%in which each procedure $p$ is augmented with an additional \textit{start node} \textsf{start}$_p$ and \textit{end node} \textsf{end}$_p$, and for each call $c_q$ to a procedure $q$, there is a \textit{call node} \textsf{call}$_{c_q}$ and subsequent \textit{return node} \textsf{return}$_{c_q}$.

%A control-flow supergraph allows us to model the control flow in inter-procedural paths.
 %The flow from the caller to the callee is represented using an edge \[(\textsf{call}_{c_q},\,\textsf{start}_q)\,.\] The control flow from the callee back to the caller goes through an edge \[(\textsf{end}_q,\,\textsf{return}_{c_q})\,.\]

A call site is \textit{monomorphic} if it always calls the same procedure. In an object-oriented language, 
a call site $r.m(\ldots)$ can dynamically dispatch to multiple methods depending on the runtime
type of the object pointed to by the receiver $r$.
A call site that calls multiple procedures is called
\textit{polymorphic}.
We define a function $\textsf{lookup}$ to specify the dynamic dispatch: 
if $s$ is the signature of $m$ and $t$ is the runtime type of the object
pointed to by $r$, $\textsf{lookup}(s,t)$ gives the procedure that will
be invoked by the call $r.m(\ldots)$. We also define a kind of inverse $\tau$
of $\textsf{lookup}$: given a signature $s$ and a specific invoked procedure
$f$, $\tau(s,f)$ gives the set of all runtime types of $r$ that cause $r.m(\ldots)$
to dispatch to $f$: $\tau(s,f) = \{t\mid \textsf{lookup}(s,t)=f\}$.

\otodo{do we ever use $\src$ and $\target$?}
We denote the source and end nodes of a graph edge $e$ as $\src e$ and $\target e$.

\commentout{
\begin{example}
  Consider the program in Listing~\ref{list:examplejava}. The supergraph corresponding to that program is shown in Figure~\ref{fig:examplesupergraph}.
  \otodo{Can we merge the examples from Figures 1 and 2 into a single example program?}
\otodo{I think we can remove the supergraph Figure 3.}
\begin{figure}
  \centering
  \begin{minipage}{\textwidth}
    \inputMinted{java}{examplesupergraph.java}
  \end{minipage}
  \caption{An example Java program}
  \label{list:examplejava}
\end{figure}
  
  \begin{figure}%
  \centering
  \scalebox{.9}{
      \tikzset{
        ashadow/.style={
          opacity=.25,
          shadow xshift=0.07,
          shadow yshift=-0.07
        },
      }
    \tikzstyle{supergraph}=[
      fill=greyblue,
      rounded corners,
      font=\small,
      align=center,
      text=charcoal,
      drop shadow={ashadow, color=greyblue}
    ]
    \tikzstyle{supergraph_s}=[
      fill=bisque,
      rounded corners,
      font=\small,
      align=center,
      text=charcoal,
      drop shadow={ashadow, color=greyblue}
    ]
    \tikzstyle{supergraph_f}=[
      fill=lightsalmonpink,
      rounded corners,
      font=\small,
      align=center,
      text=charcoal,
      drop shadow={ashadow, color=greyblue}
    ]
    \tikzstyle{description}=[fill=white]
\begin{tikzpicture}

% main method nodes
    \node [supergraph] (st_main) {\textsf{start}$_{\texttt{main}}$};
    \node [supergraph] (call_secret) [below = \dist of st_main.south] {\textsf{call}$_\texttt{secret}$};
    \node [supergraph] (return_secret) [below = \dist of call_secret.south] {\textsf{return}$_\texttt{secret}$\\\texttt{a = secret()}};
    \node [supergraph] (call_f_main) [below = \dist of return_secret.south] {\textsf{call}$_\texttt{A.f}$};
    \node [supergraph] (return_f_main) [below = \dist of call_f_main.south] {\textsf{return}$_\texttt{A.f}$\\\texttt{b = f(a)}};
    \node [supergraph] (end_main) [below = \dist of return_f_main.south] {\textsf{end}$_{\texttt{main}}$};
% main method edges
    \path[->] (st_main) edge (call_secret);
    \path[->] (call_secret) edge (return_secret);
    \path[->] (return_secret) edge (call_f_main);
    \path[->] (call_f_main) edge (return_f_main);
    \path[->] (return_f_main) edge (end_main);
    
%secret method nodes
    \node [supergraph_s] (st_secret) [above right = 2*\dist and 6*\dist of st_main] {\textsf{start}$_{\texttt{secret}}$};
    \node [supergraph_s] (return_secret_string) [below = \dist of st_secret.south] {\texttt{return "secret"}};
    \node [supergraph_s] (end_secret) [below = \dist of return_secret_string.south] {\textsf{end}$_\texttt{secret}$};
%secret method edges
    \path[dashed,->] (call_secret) edge[out=20,in=130,->] (st_secret);
    \path[->] (st_secret) edge (return_secret_string);
    \path[->] (return_secret_string) edge (end_secret);
    \path[dashed,->] (end_secret) edge[out=240,in=5] (return_secret);

%f method nodes
    \node [supergraph_f] (st_f) [below right = 2*\dist and \dist of end_secret.south] {\textsf{start}$_\texttt f$};
    \node [supergraph_f] (if) [below = \dist of st_f.south] {\texttt{if (s == null)}};
    \node [supergraph_f] (return_x) [below right = \dist and 2*\dist of if.south] {\texttt{return s}};
    \node [supergraph_f] (call_f_f) [below left = \dist and 2*\dist of if.south] {\textsf{call}$_\texttt{f}$};
    \node [supergraph_f] (return_f_f) [below = \dist of call_f_f.south] {\textsf{return}$_\texttt{f}$\\\texttt{r = f("not secret")}};
    \node [supergraph_f] (return_r) [below = \dist of return_f_f.south] {\texttt{return r}};
    \node [supergraph_f] (end_f) [below right = \dist and 2*\dist of return_r.south] {\textsf{end}$_\texttt f$};
%f method edges
    \path[dashed,->] (call_f_main) edge[out=0,in=160] (st_f);
    \draw[->] (st_f) edge (if);
    \draw[->] (if) edge [out=210,in=45] (call_f_f);
    \draw[->] (call_f_f) edge (return_f_f);
    \draw[dashed,->] (call_f_f) [out=170,in=200] edge (st_f);
    \draw[->] (return_f_f) edge (return_r);
    \draw[->] (return_r) edge [out=-80,in=175] (end_f);
    \draw[->] (if) edge [out=330,in=135] (return_x);
    \draw[->] (return_x) edge [out=270,in=10] (end_f);
    \draw[dashed,->] (end_f) edge [out=200,in=180] (return_f_f);
    \draw[dashed,->] (end_f) edge [out=215,in=-50] (return_f_main);
    
%arrow description
    \node [description] (intra_arrow_left) [above right = \dist and 2*\dist of st_secret] {};
    \node [description] (intra_arrow_right) [right = \dist of intra_arrow_left] {};
    \node [description] (inter_arrow_left) [below = .5*\dist of intra_arrow_left] {};
    \node [description] (inter_arrow_right) [below = .5*\dist of intra_arrow_right] {};
    \path[->](intra_arrow_left) edge node[right = .5*\dist]{intra-procedural edge} (intra_arrow_right);
    \path[dashed,->](inter_arrow_left) edge node[right = .5*\dist]{inter-procedural edge} (inter_arrow_right);
\end{tikzpicture}
}
  \caption{An example supergraph for Listing~\ref{list:examplejava}}%
  \label{fig:examplesupergraph}%
  \end{figure}
\end{example}
}

%A \textit{flow-sensitive} data-flow analysis is one that takes the order of program instructions into account.

A path through the control-flow supergraph is \textit{valid} if every end-to-return edge on the path returns
to the site of the most recent unmatched call. The set of all valid paths from the program entry point to
a node $n$ is denoted $\ivp(n)$.
\otodo{Should we give a formal definition?}

%Let each call node in a program be labeled with a distinct opening parenthesis and the corresponding return node with the matching closing parenthesis. For a given path $p$, let $s$ be the string that is obtained by concatenating the labels of the nodes in $p$.
%Then $p$ is \textit{valid} if $s$ belongs to the language of substrings of balanced parentheses. The set of all inter-procedurally valid paths from the start node to a node $n$ is denoted as $\ivp(n)$. The set $\ivp(n)$ is a conservative approximation of all concrete execution paths from the start node to $n$.

%A \textit{context-sensitive} data-flow analysis is an analysis that considers only inter-procedurally valid paths.

\commentout{
\begin{mdelete}
\begin{example}
  In the supergraph in Figure~\ref{fig:examplesupergraph}, let us assign $\{,\,\}$ parentheses to $\textsf{call}_\texttt{A.f}$ and $\textsf{return}_\texttt{A.f}$, and $\langle,\,\rangle$ parentheses to $\textsf{call}_\texttt{f}$ and $\textsf{return}_\texttt{f}$. 
  Then the string corresponding to the path 
  \[
    p_1=\left[\highlight{\textsf{call}_\texttt{A.f}}{greyblue},\,
          \highlight{\textsf{start}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\texttt{if (s == null)}}{lightsalmonpink},\,
          \highlight{\texttt{return s}}{lightsalmonpink},\,
          \highlight{\textsf{end}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\textsf{return}_\texttt{A.f}}{greyblue}
    \right]
  \]
  is $\{\}$, which indicates that $p_1$ is valid. Every prefix of $p_1$ is also a valid path.
  
\mtodo{The figure that we deleted was constructed so that there would be a realizable and a non-realizable path. Now that we deleted that figure, let's delete this example as well.}  
  
However, the graph also contains an inter-procedurally invalid path
  \[
    p_2=\left[\highlight{\textsf{call}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\textsf{start}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\texttt{if (s == null)}}{lightsalmonpink},\,
          \highlight{\texttt{return s}}{lightsalmonpink},\,
          \highlight{\textsf{end}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\textsf{return}_\texttt{A.f}}{greyblue}
    \right]
  \]
  with corresponding string $\langle\}$.
\end{example}
\end{mdelete}
}

\otodo{The definitions that Marianna had were for \emph{complete}
lattices/semilattices. All of the lattices in the context of IFDS/IDE
are/must be complete. I'll just say that here.}
A \textit{complete lattice} is a partially ordered set $(S,\sqsubseteq)$ in which every subset has a least upper bound and a greatest lower bound.
A \textit{complete meet semilattice} is a partially ordered set in which every subset need only have a greatest lower bound.
The symbols $\bot$ and $\top$ are used to denote the greatest lower bound of $S$ and of the empty set, respectively.
Since all of the (semi)lattices discussed in this paper are required to be complete, we will henceforth leave out the
\textit{complete} qualifier.


%A \textit{meet semilattice} $L=(S,\,\sqcap)$ is defined by a set $S$ and a meet operation $\sqcap$ that is  associative, commutative, and idempotent.
  %The meet operation induces a partial order $(S,\,\sqsubseteq)$ where every subset contains  a greatest lower bound: For all $x,\,y\in S$, $x\sqsubseteq y$ if $x\sqcap y=x$. The greatest lower bound, or top element, of the semilattice is denoted as $\top$.
  %If $k$ is the length of the longest chains of elements in the semilattice, then the \textit{height} of the semilattice is~$k-1$.

In this paper, we denote a map $m$ as a set of pairs of keys and values, in which each key appears at most once.
For any map $m$,  $m(k)$ is the value paired with the key $k$ in $m$. We denote by $m[x\to y]$ a map that maps $x$ to $y$, and every other key $k$ to $m(k)$.
%To avoid excessive parentheses, we write $\left(m[x_1\to y_1]\right)[x_2\to y_2]$ as $m[x_1\to y_1][x_2\to y_2]$.

%We will denote the identity function $\lambda x\,.x$ by $\textsf{id}$.
%We will use a typed version of this function in various contexts, where the type of $x$ will vary with
%the context.

%OL: we can just as easily write the identity explicitly as \x.x throughout.

\subsection{IFDS}\label{sec:bgifds}
The IFDS framework~\cite{reps1995precise} is a precise and efficient algorithm for data-flow analysis
%. IFDS was developed in 1995 by T.\,Reps, S.\,Horwitz, and M.\,Sagiv at the University of Wisconsin and
that has been used to solve a variety of data-flow analysis problems~\cite{bodden2013spl,naeem2008typestate,DBLP:conf/birthday/KreikerRRSWY13,tripp2009taj}.
%\mtodo{ The four references take away space in the References section. Remove some of them?  }
The IFDS framework is an instance of the \textit{functional approach} to data-flow analysis~\cite{pnueli1981two}
because it constructs summaries of the effects of called procedures.
\commentout{The IFDS analysis is a version of the classic \textit{functional approach} to data-flow analysis proposed by M.\,Sharir and A.\,Pnueli~\cite{pnueli1981two}.}
\commentout{In other data-flow algorithms not based on the functional approach, the result of the analysis at the entry of a procedure ``merges'' the incoming data obtained from all callers of the procedure. As a consequence, there is one global data-flow result computed at the end of the procedure. Context-sensitivity, however, allows an analysis to compute the data-flow result for a given procedure as a \textit{function} of the data-flow value at the start of the procedure. 
In other words, the analysis result for a procedure varies depending on where the procedure was called from. This significantly improves the precision of a data-flow analysis, which is why context-sensitivity is an important advantage of IFDS over classic data-flow algorithms.}
\mtodo{I'm not saying any more that IFDS is a version of Sharir\&Pnueli's functional approach.}
\mtodo{I also removed the comparison of IFDS with other algorithms. I'm not pointing out the benefits of IFDS any more, so we might fail to show the importance of the algorithm.}
The IFDS framework is applicable to \textit{inter-procedural} data flow problems whose domain is \textit{subsets} of a \textit{finite} set $D$,
and whose data-flow functions are \textit{distributive}.
A function $f$ is distributive if 
$f(x_1\sqcap x_2)=f(x_1)\sqcap f(x_2)$.

%The IFDS algorithm is applicable to problems which can be expressed with data-flow functions that satisfy certain restrictions. \textit{Inter-procedural} flow functions specify how data flows from the invocation of a procedure to its start, and from the procedure's end back to its call site. \textit{Distributive} flow functions are those that distribute over the confluence operator. In the context of IFDS, the confluence operator is called meet, and it can be either union or intersection. The data-flow facts on which the analysis operates must be a \textit{finite} set $D$. Each flow function operates on a \textit{subset} of $D$ (for example, the set of variables in the program) which makes the domain of the flow functions the power set of $D$.

\commentout{The purpose of the IFDS framework is to solve a special subset of inter-procedural, flow-sensitive, context-sensitive data-flow-analysis problems. The main idea of IFDS is to encode the data-flow analysis problem into a graph-reachability problem.}

The IFDS algorithm is notable because it computes a meet over valid paths solution in polynomial time.
Most other interprocedural analysis algorithms are either imprecise due to invalid paths,
general but do not run in polynomial time~\cite{knoop1992interprocedural,pnueli1981two}, or handle a very specific set of problems~\cite{knoop1993efficient}.

%\subsubsection{Data-Flow Problems Suitable for IFDS}\label{sec:suitableifds}
\commentout{In this section we describe the data-flow problems that can be solved by an IFDS analysis. We will start with an intuitive definition and later on formalize the notion of an IFDS-suitable problem.}

%Informally, an IFDS analysis can only solve decision problems. An IFDS analysis answers questions of the following kind: ``is property $X$ true at program point~$Y$?''. For example, a taint-analysis problem asks, for each variable $v$ in the program, ``is $v$ secret at a given program point?''. 
\commentout{An available-expressions problem asks, for each expression $e$, ``does $e$ have to be recomputed at a given program point?''.}

The input to the IFDS algorithm is specified as
%Formally, a data-flow analysis problem is suitable for an IFDS analysis if it can be encoded as an IFDS problem
  $(G^*,\,D,\,F,\,M_F,\,\sqcap)$,
where $G^*=(N^*,\,E^*)$ is the supergraph of the input program with nodes $N^*$ and edges $E^*$,
$D$ is a finite set of \textit{data-flow facts},
$F$ is a set of distributive dataflow functions of type $2^D\to2^D$,
$M_F:\,E^*\to F$ assigns a dataflow function to each supergraph edge,
and $\sqcap$ is the \textit{meet operator} on the powerset $2^D$, either union or intersection.
In our presentation, the meet will always be union, but all of the results apply dually when the
meet is intersection.

The output of the IFDS algorithm is, for each node $n$ in the supergraph, the \textit{meet-over-all-valid-paths} solution
 $\mvp{F}(n)=\bigsqcap_{q\in\ivp(n)}M_F(q)(\top)$, where $M_F$ is extended from edges to paths by composition.

\commentout{
is a function that maps supergraph edges to dataflow functions, and $M_F$ is extended to paths by composition\footnote{%
  Let $A$ be a set and $f:\,E^*\to(A\to A)$ a function from supergraph edges to functions on $A$.
  We say that $f$ is extended to  paths by composition to denote that for a path $q$ consisting of the edges $e_1,\,\dots,\,e_k$, $f(q)=f(e_k)\circ\ldots\circ f(e_1)\circ\id$.
}. The \textit{meet operator} $\sqcap$ is either union or intersection.
}

%Without loss of generality, we will take meet to denote union. It can be shown that any problem where meet is defined as intersection can be reformulated into an equivalent one where meet is defined as union~\cite{reps1995precise}.

\subsubsection{Overview of the IFDS Algorithm}\label{sec:overviewifds}
The key idea behind the IFDS algorithm is that it is possible to represent any distributive
function $f$ from $2^D$ to $2^D$ by a \textit{representation relation} $R_f \subseteq 
(D \cup \{0\})
\times
(D \cup \{0\})$. The representation relation can be visualized as a bipartite graph
with edges from one instance of $D \cup \{0\}$ to another instance of $D \cup \{0\}$.
The IFDS algorithm uses such graphs to efficiently represent both the input dataflow functions
and the summary functions that it computes for called procedures.
Specifically, the representation relation $R_f$ of a function $f$ is defined as:
\[
R_f=\{(\mathbf0,\,\mathbf0)\}\cup
      \{(\mathbf0,\,d_j)\,|\,d_j\in f(\varnothing)\}\cup
      \{(d_i,\,d_j)\,|\,d_j\in f(\{d_i\}) \setminus f(\varnothing)\}.
\]
%Each pair $(d_i,\,d_j)\in R_f$ corresponds to an edge $((n_1,\,d_i),\,(n_2,\,d_j))$ in the exploded supergraph.

\commentout{
Note that $R_f$ constructs pairs of dataflow facts so that
\begin{itemize}
  \item there is always an edge $(\mathbf0,\,\mathbf0)$ corresponding to the control-flow-graph edge;
  \item if there is an edge $(\mathbf0,\,d_j)$, then there is no other edge leading to $d_j$; in particular, there is never an edge $(d_i,\,\mathbf0)$ where $d_i\ne\mathbf0$.
\end{itemize}
}

\begin{example}\label{ex:flowfun}
    Given $D=\{u,\,v,\,w\}$ and $f(S) = S\setminus\{v\} \cup \{u\}$,
    the representation relation 
  %The representation relation $R_f$ for a set of data-flow facts 
  %and dataflow function $f=\lambda S\,.\,S\setminus\{v\}\cup\{u\}$ looks as follows:
  $
    R_f=\{(\mathbf0,\,\mathbf0),\,(\mathbf0,\,u),\,(w,\,w)\}
$, which can be visualized with the following graph:
   \begin{center}
    \tikzstyle{n}=[fill=black,circle,inner sep=1.5pt]
\begin{tikzpicture}[>=stealth,on grid, auto]
    \node [n,label=$\mathbf{0}$] (zero){};
    \node [n,] (zero_) [below=\edge of zero] {};
    \node [n,label=$u$] (u) [right=\nd of zero] {};
    \node [n,] (u_) [below=\edge of u] {};
    \node [n,label=$v$] (v) [right=\nd of u] {};
    \node [n,] (v_) [below=\edge of v] {};
    \node [n,label=$w$] (w) [right=\nd of v] {};
    \node [n,] (w_) [below=\edge of w] {};
    \path[->](zero) edge (zero_);
    \path[->](zero) edge (u_);
    \path[->](w) edge (w_);
  \end{tikzpicture}
  \end{center}
\end{example}

The representation relation decomposes a flow function into functions
(edges) that operate on each fact individually. This is possible due
to distributivity: applying the flow function to a set of facts is
equivalent to applying it on each fact individually and
taking the union of the results.

The meet of two functions can be computed as simply the union of their representation
functions: $R_{f\sqcap f'} = R_f \cup R_{f'}$. The composition of two functions can be
computed by combining their representation graphs, merging the range nodes of the
first function with the corresponding domain nodes of the second function, and finding
paths in the resulting graph.

\commentout{
The representation relation allows us to compactly represent the composition and meet operations which are required for the IFDS algorithm.

For two representation relations $R_{f_1},\,R_{f_2}$, the composition and meet operations are defined as follows:
\begin{align}
  R_{f_1}\circ R_{f_2}&=\{(d_1,\,d_3)\ |\ \exists d_2:\ (d_1,\,d_2)\in R_{f_1},\,(d_2,\,d_3)\in R_{f_2}\}\,.
\intertext{and}
  R_{f_1}\sqcap R_{f_2}&=R_{f_1}\cup R_{f_2}\,.
\end{align}

The representation relation distributes over composition and meet:
\begin{align}
  R_{f_1}\circ R_{f_2}=R_{f_1\circ f_2}\,,\qquad
\text{and}\qquad
  R_{f_1}\sqcap R_{f_2}=R_{f_1\sqcap f_2}\,.
\end{align}
}

%On the exploded graph, the composition of two functions is represented by the paths that are formed when the exploded-graph edges are combined.
\otodo{The example used to say $R_f \circ R_g$, but I believe it showed $R_g \circ R_f$. I fixed it, but please check that this is correct.}

\begin{example}
    If $g(S)=S\setminus\{w\}$ and $f(S) = S\setminus\{v\} \cup \{u\}$, then
    $
    R_g\circ R_f=\{(\mathbf0,\,\mathbf0),\,(\mathbf0,\,u)\},
    $
  as illustrated in the following graph:
    \begin{center}
    \tikzstyle{n}=[fill=black,circle,inner sep=1.5pt]
\begin{tikzpicture}[>=stealth,on grid, auto]
    \node [n,label=$\mathbf{0}$] (zero){};
    \node [n] (zero_) [below=\edge of zero] {};
    \node [n,label=$u$] (u) [right=\nd of zero] {};
    \node [n] (u_) [below=\edge of u] {};
    \node [n,label=$v$] (v) [right=\nd of u] {};
    \node [n] (v_) [below=\edge of v] {};
    \node [n,label=$w$] (w) [right=\nd of v] {};
    \node [n] (w_) [below=\edge of w] {};
    \node [n] (zero__) [below=\edge of zero_] {};
    \node [n] (u__) [below=\edge of u_] {};
    \node [n] (v__) [below=\edge of v_] {};
    \node [n] (w__) [below=\edge of w_] {};

    \path[->](zero) edge node[left] {$R_f$} (zero_);
    \path[->](zero) edge (u_);
    \path[->](w) edge (w_);
    \path[->](zero_) edge node[left] {$R_g$} (zero__);
    \path[->](u_) edge (u__);
    \path[->](v_) edge (v__);
    
    \node [n,label=$\mathbf{0}$] (zeroC) [below right= .5\edge and 3.5\dist of w] {};
    \node [n] (zeroC_) [below=\edge of zeroC] {};
    \node [n,label=$u$] (uC) [right=\nd of zeroC] {};
    \node [n] (uC_) [below=\edge of uC] {};
    \node [n,label=$v$] (vC) [right=\nd of uC] {};
    \node [n] (vC_) [below=\edge of vC] {};
    \node [n,label=$w$] (wC) [right=\nd of vC] {};
    \node [n] (wC_) [below=\edge of wC] {};

    \path[->](zeroC) edge node[left] {$R_g\circ R_f$} (zeroC_);
    \path[->](zeroC) edge (uC_);
  \end{tikzpicture}
  \end{center}
\end{example}

Composition of two distributive
functions $f$ and $f'$ corresponds to finding reachable nodes in a graph composed from their representation
relations $R_f$ and $R_{f'}$. Therefore, evaluating the composed dataflow function for a control
flow path corresponds to finding reachable nodes in a graph composed from the representation relations
of the dataflow functions for individual instructions.

It is this graph of representation relations that the IFDS algorithm operates on.
In this graph, called the \textit{exploded supergraph}, each node is a pair $(n,d)$, where
$n\in N^*$ is a node of the control-flow supergraph and $d$ is an element of $D\cup\{0\}$.
For each edge $(n \to n') \in E^*$, the exploded supergraph contains a set of edges
$(n,d_i) \to (n',d_j)$, which form the representation relation of the dataflow function
$M_F(n \to n')$. The IFDS algorithm finds all exploded supergraph edges that are reachable by
\textit{realizable} paths in the exploded supergraph. A path
is \textit{realizable} if its projection to the (non-exploded) supergraph is a valid
path (i.e. if it is of the form $(n_0, d_0) \to (n_1,d_1) \to \cdots \to (n_m,d_m)$
and $n_0 \to n_1 \to \cdots \to n_m$ is a valid path).



\commentout{
To compute the meet-over-all-valid-paths solution, each node in the control-flow supergraph is paired with a \textit{fact} $d\in D\cup\{\mathbf0\},\,\mathbf0\notin D$, yielding the nodes $N^\#$ of the \textit{exploded supergraph} $G^\#=(N^\#,\,E^\#)$.
Roughly, for each node in the program, a fact denotes a binary property whose value (true or false) we want to find out.
The start node of the exploded supergraph is the node $(\startmain,\,\mathbf0)$.

The flow functions $F$ define the edges of the exploded supergraph.
Using the flow functions, the IFDS algorithm computes the inter-procedurally \textit{realizable} paths from the start to the rest of the exploded graph's nodes. A realizable path is a valid path in the exploded supergraph that starts with the entry node $\startmain$.

If there is a realizable path from the node $(\startmain,\,\mathbf0)$ to a given node $(n,\,d),\,d\ne\mathbf0$, then the fact $d$ is considered to hold at node $n$. A path to a node $(n,\,\mathbf0)$ means that in the control-flow supergraph, there is a path from $\startmain$ to $n$.

In this way, the IFDS algorithm reduces the input data-flow problem to a graph-reachability problem.
\begin{example}
  In a taint analysis, $D$ is the set of variables in the program. If a fact $d\in D$ is reachable at a given node, then the variable is considered secret at that node. Otherwise, it is considered not secret. The question ``is $d$ secret at node $n$?'' becomes ``is there a realizable path from (\textsf{start}$_\texttt{main}$,\,\textbf{0}) to $(n,\,d)$?''.
\end{example}
\commentout{\begin{example} 
  In an available-expressions analysis, $D$ is the set of all expressions in the program. If an expression $d\in D$ is reachable at a certain node, it means that it does not need to be recomputed at that node. 
\end{example}}
}
\begin{example}
  The exploded supergraph for Listing~\ref{list:ccexample} is shown in Figure~\ref{fig:cc_edgefn_example}.\mtodo{Tell the reader here to ignore the labels on the edges of the graph?}
  We can see that there is a realizable path
  from the start node of the exploded graph to the variable \verb's' at~the~node~$\textsf{print(s)}$ in the \verb'B.bar' method. This means that at that node, \verb's' is considered secret.

\commentout{  
    \begin{figure}%
      \hspace*{-30pt}
\scalebox{.9}{
      \tikzset{
        ashadow/.style={
          opacity=.25,
          shadow xshift=0.07,
          shadow yshift=-0.07
        },
      }
    \tikzstyle{supergraph}=[
      fill=greyblue,
      rounded corners,
      font=\small,
      align=right,
      text=charcoal,
      drop shadow={ashadow, color=greyblue}
    ]
    \tikzstyle{supergraph_s}=[
      fill=bisque,
      rounded corners,
      font=\small,
      align=left,
      text=charcoal,
      drop shadow={ashadow, color=greyblue}
    ]
    \tikzstyle{supergraph_f}=[
      fill=lightsalmonpink,
      rounded corners,
      font=\small,
      align=left,
      text=charcoal,
      drop shadow={ashadow, color=greyblue}
    ]
    \tikzstyle{description}=[fill=white]
    \tikzstyle{n}=[fill=black,circle,inner sep=1.5pt]
    
\begin{tikzpicture}[>=stealth,on grid, auto]

% main method nodes
    \node [supergraph] (st_main) {\textsf{start}$_{\texttt{main}}$};
    \node [supergraph] (call_secret) [below = \dist of st_main.south east, anchor=east] {\textsf{call}$_\texttt{secret}$};
    \node [supergraph] (return_secret) [below = \dist of call_secret.south east,anchor=east] {\textsf{return}$_\texttt{secret}$\\\texttt{a = secret()}};
    \node [supergraph] (call_f_main) [below = \dist of return_secret.south east, anchor=east] {\textsf{call}$_\texttt{A.f}$};
    \node [supergraph] (return_f_main) [below = \dist of call_f_main.south east, anchor=east] {\textsf{return}$_\texttt{A.f}$\\\texttt{b = f(a)}};
    \node [supergraph] (end_main) [below = \dist of return_f_main.south east, anchor=east] {\textsf{end}$_{\texttt{main}}$};
    
    \node [n,label=$\mathbf{0}$] (st_main_z) [right=\ndd of st_main.east] {};
    \node [n,label=\texttt{a}] (st_main_x) [right=\ndd of st_main_z] {};
    \node [n,label=\texttt{b}] (st_main_y) [right=\ndd of st_main_x] {};
    
    \node [n] (call_secret_z) [right=\ndd of call_secret.east] {};
    \node [n] (call_secret_x) [right=\ndd of call_secret_z] {};
    \node [n] (call_secret_y) [right=\ndd of call_secret_x] {};
    
    \node [n] (return_secret_z) [right=\ndd of return_secret.east] {};
    \node [n] (return_secret_x) [right=\ndd of return_secret_z] {};
    \node [n] (return_secret_y) [right=\ndd of return_secret_x] {};
    
    \node [n] (call_f_main_z) [right=\ndd of call_f_main.east] {};
    \node [n] (call_f_main_x) [right=\ndd of call_f_main_z] {};
    \node [n] (call_f_main_y) [right=\ndd of call_f_main_x] {};
    
    \node [n] (return_f_main_z) [right=\ndd of return_f_main.east] {};
    \node [n] (return_f_main_x) [right=\ndd of return_f_main_z] {};
    \node [n] (return_f_main_y) [right=\ndd of return_f_main_x] {};
    
    \node [n] (end_main_z) [right=\ndd of end_main.east] {};
    \node [n] (end_main_x) [right=\ndd of end_main_z] {};
    \node [n] (end_main_y) [right=\ndd of end_main_x] {};
% main method edges
    \path[->](st_main_z) edge (call_secret_z);
    \path[->](call_secret_z) edge (return_secret_z);
    \path[->](return_secret_z) edge (call_f_main_z);
    \path[->](call_f_main_z) edge (return_f_main_z);
    \path[->](return_f_main_z) edge (end_main_z);  
    \path[->](return_f_main_y) edge (end_main_y);    
    
%secret method nodes
    \node [supergraph_s] (st_secret) [above right = 2*\dist and 6*\dist of st_main] {\textsf{start}$_{\texttt{secret}}$};
    \node [supergraph_s] (return_secret_string) [below = \dist of st_secret.south west, anchor=west] {\texttt{return "secret"}};
    \node [supergraph_s] (end_secret) [below = \dist of return_secret_string.south west,anchor = west] {\textsf{end}$_\texttt{secret}$};
    
    \node [n,label=$\mathbf{0}$] (st_secret_z) [left=\ndd of st_secret.west] {};
    \node [n] (return_secret_string_z) [left=\ndd of return_secret_string.west] {};
    \node [n] (end_secret_z) [left=\ndd of end_secret.west] {};
%secret method edges
    \path[->](st_secret_z) edge (return_secret_string_z); 
    \path[->](return_secret_string_z) edge (end_secret_z); 
    \path[->,dashed](call_secret_z) edge [out=30,in=180] (st_secret_z);
    \path[->,dashed](end_secret_z) edge [out=240,in=40] (return_secret_z);
    \path[->,dashed](end_secret_z) edge [out=260,in=30] (return_secret_x);
    \path[->](return_secret_x) edge (call_f_main_x);
    \path[->](call_f_main_x) edge (return_f_main_x);
    \path[->](return_f_main_x) edge (end_main_x);

%f method nodes
    \node [supergraph_f] (st_f) [below=2*\dist of end_secret.south west,anchor=west] {\textsf{start}$_\texttt f$};
    \node [supergraph_f] (if) [below = \dist of st_f.south west,anchor=west] {\texttt{if (s == null)}};
    \node [supergraph_f] (return_x) [below right = \dist and 2.5*\dist of if.south] {\texttt{return s}};
    \node [supergraph_f] (call_f_f) [below=\dist of if.south west,anchor=west] {\textsf{call}$_\texttt{f}$};
    \node [supergraph_f] (return_f_f) [below = \dist of call_f_f.south west,anchor=west] {\textsf{return}$_\texttt{f}$\\\texttt{r = f("not secret")}};
    \node [supergraph_f] (return_r) [below = \dist of return_f_f.south west,anchor=west] {\texttt{return r}};
    \node [supergraph_f] (end_f) [below=\dist of return_r.south west,anchor=west] {\textsf{end}$_\texttt f$};
   
     \node [n,label=\texttt{s}] (st_f_s) [left=\ndd of st_f.west] {}; 
     \node [n,label=\texttt{r}] (st_f_r) [left=\ndd of st_f_s] {};
     \node [n,label=$\mathbf{0}$] (st_f_z) [left=\ndd of st_f_r] {};
     
     \node [n] (if_s) [left=\ndd of if.west] {};
     \node [n] (if_r) [left=\ndd of if_s] {};
     \node [n] (if_z) [left=\ndd of if_r] {};
     
     \node [n] (call_f_f_s) [left=\ndd of call_f_f.west] {};
     \node [n] (call_f_f_r) [left=\ndd of call_f_f_s] {};
     \node [n] (call_f_f_z) [left=\ndd of call_f_f_r] {};
     
     \node [n] (return_f_f_s) [left=\ndd of return_f_f.west] {};
     \node [n] (return_f_f_r) [left=\ndd of return_f_f_s] {};
     \node [n] (return_f_f_z) [left=\ndd of return_f_f_r] {};
     
     \node [n] (return_r_s) [left=\ndd of return_r.west] {};
     \node [n] (return_r_r) [left=\ndd of return_r_s] {};
     \node [n] (return_r_z) [left=\ndd of return_r_r] {};
     
     \node [n] (end_f_s) [left=\ndd of end_f.west] {};
     \node [n] (end_f_r) [left=\ndd of end_f_s] {};
     \node [n] (end_f_z) [left=\ndd of end_f_r] {};
     
     \node [n,label=$\mathbf0$] (return_x_z) [right=\ndd of return_x.east] {};
     \node [n,label=\texttt{r}] (return_x_r) [right=\ndd of return_x_z] {};
     \node [n,label=\texttt{s}] (return_x_s) [right=\ndd of return_x_r] {};
%f method edges
    \path[->](st_f_z) edge (if_z);
    \path[->](if_z) edge (call_f_f_z);
    \path[->](call_f_f_z) edge (return_r_z);  
    \path[->](return_r_z) edge (end_f_z);
    \path[->](if_z) edge [out=-43,in=127] (return_x_z);
    \path[->](return_x_z) edge [out=270,in=25] (end_f_z);
    \path[->](st_f_s) edge (if_s);
    \path[->](if_s) edge (call_f_f_s);
    \path[->](call_f_f_s) edge (return_r_s);  
    \path[->](return_r_s) edge (end_f_s);
    \path[->](if_s) edge [out=-30,in=110] (return_x_s);
    \path[->](return_x_s) edge [out=270,in=25] (end_f_s);
    \path[->](return_f_f_r) edge (return_r_r);
    \path[->](return_r_r) edge (end_f_r);
    \path[->,dashed](call_f_main_z) edge [out=20,in=160] (st_f_z);
    \path[->,dashed](end_f_z) edge [out=150,in=-20] (return_f_main_z);
    \path[->,dashed](call_f_f_z) edge [out=110,in=250] (st_f_z);
    \path[->,dashed](end_f_z) edge [out=110,in=250] (return_f_f_z);
    \path[->,dashed](call_f_main_x) edge [out=32,in=112] (st_f_s);
    \path[->,dashed](end_f_s) edge [out=155,in=-40] (return_f_main_y);
    \path[->,dashed](end_f_s) edge [out=120,in=-50] (return_f_f_r);
    \path[->,dashed](end_f_r) edge [out=110,in=250] (return_f_f_r);
    \path[->,dashed](end_f_r) edge [out=150,in=-50] (return_f_main_y);
\end{tikzpicture}
}
  \caption{The exploded supergraph corresponding to a taint analysis for the input program in Listing~\ref{list:examplejava}}%
  \label{fig:exampleexploded}%
  \end{figure}
}
\end{example}



\mtodo{We never use the interpretation function, so I deleted it, too}
\commentout{
To convert a representation relation $R_f$ back into the original flow function $f$, we can use the \textit{interpretation} function $\denote {R_f}$:
\begin{align}
  f&=\denote{R_f}\notag\\
  &=\lambda D_1\,.\,\left(\left\{d_2\ |\ \exists d_1\in D_1:\,(d_1,\,d_2)\in R_f\right\}\cup\{d_2\ |\ (\mathbf0,\,d_2)\in R_f\}\right)
  \setminus\{\mathbf0\}\,.
\end{align}
}

A practical implementation of the IFDS algorithm generally takes as input a representation of the
exploded supergraph edges $E^\sharp$ instead of explicit dataflow functions $M_F$. This is convenient because
the two are equivalent in expressiveness, and because the IFDS algorithm works internally with the exploded
supergraph. More specifically, the input generally provides a function
$f: N^* \times D \times N^* \to 2^D$. Given a (non-exploded) supergraph edge $n \to n'$ and a dataflow fact $d$,
$f(n,d,n')$ returns the set of all $d'$ such that the exploded supergraph contains the edge $(n,d) \to (n',d')$.
For convenience, the function $f$ can be split up into separate functions that handle the cases when
the $n\to n'$ is an intraprocedural edge, a call-to-start edge, or an end-to-return edge.

%We presented an overview of the IFDS analysis. IFDS problems are transformed into IDE problems by the correlated-calls analysis. The IDE framework is described in the next section.

\subsection{IDE}\label{sec:bgide}
\commentout{
There exists an entire class of data-flow problems that cannot be formulated as IFDS problems. Informally, the problems cannot be formulated as decision problems. For instance, a constant-propagation problem asks, for each variable $v$ in the program, ``if $v$ is a constant at a given program point, what is $v$'s value?''.
The questions asked by constant propagation are of the form ``if property $X$ \textit{($v$ being a constant)} is true at program point~$Y$, what is the value of some property~$Z$ \textit{(the value of the constant)} corresponding to~$X$?''. It turns out that problems with such questions can often be solved by the IDE algorithm.

The IDE framework is an expressive extension to IFDS that was created by the same authors in 1996.
The problems that IDE can solve include, but are not limited to, IFDS problems~\cite{reps1995precise}. Just as the IFDS algorithm, the IDE algorithm is suitable for data-flow analyses that can be encoded with inter-procedural, distributive flow functions. However, in IDE, the domain of the flow functions is not restricted to sets $D$ of data-flow facts. The IDE domain of a flow function consists of \textit{environments} that map data-flow facts from the set $D$ to lattice elements.

As an example, in a constant propagation problem, an IDE environment would map each variable to the (possibly) constant value that it is bound to. To illustrate the distinction between IFDS and IDE we could say that IFDS can find out which variables in a program are constants, whereas IDE can additionally retrieve the values of the constant variables.
Instead of just telling us whether a fact holds or not, the IDE analysis can provide us with additional information about facts. 

Just as in the IFDS analysis, the IDE algorithm reduces a data-flow problem to a graph-reachability problem. Additionally, for each program point, the algorithm computes an \textit{environment} $\textsf{Env}(D,\,L)$, where data-flow facts are mapped to values of a lattice $L$.
}

The IDE algorithm~\cite{sagiv1996precise} extends IFDS to
\textit{inter-procedural} \textit{distributive} \textit{environment}
problems. An \textit{environment} problem is an analysis whose dataflow
lattice is the lattice $\textsf{Env}(D,L)$ of maps from a finite set $D$ to a meet semilattice
$L$ of finite height, ordered pointwise. Like IFDS, IDE requires the dataflow functions to be distributive.


\commentout{
\begin{mdelete}
For example, using the IDE analysis, we can encode a restricted version of a constant-propagation analysis\footnote{%
  In the general case, constant propagation cannot be encoded with distributive flow functions and is therefore not suitable for an IDE analysis~\cite{muller2001complexity}.
}. The data-flow facts  correspond to program variables, and the lattice incorporates all possible values for constants. 
If a fact $d$ in the exploded supergraph is reachable at node $n$, and $\textsf{Env}(d)\notin\{\bot,\,\top\}$, it means that the variable associated with $d$ is a constant. Furthermore, the value of the constant can be inferred from the environment for the corresponding node and is equal to $\textsf{Env}(d)$.
\end{mdelete}
}

The input to the IDE algorithm is
  $(G^*,\,D,\,L,\,M_\textsf{Env})$
where $G^*$ is a control-flow supergraph,
$D$ is a set of data-flow facts,
$L$ is a meet semilattice of finite height,
and $M_\textsf{Env}:\,E^*\to(\textsf{Env}(D,\,L)\to \textsf{Env}(D,\,L))$ assigns a dataflow function
to each supergraph edge.

The output of the IDE algorithm is, for each node $n$ in the supergraph,
the \textit{meet-over-all-valid-paths} solution
  $\mvp{\textsf{Env}}(n)=\bigsqcap_{q\in\ivp(n)}M_\textsf{Env}(q)(\top)$,
where $M_\textsf{Env}$ is extended from edges to paths by composition.

\commentout{
and
\begin{equation}
  \Omega=\lambda d\,.\,\top
\end{equation}
is the top element in the environment lattice~$\mathsf{Env}(D,\,L)$.
}

\commentout{
The IDE analysis is a generalization of the IFDS analysis: every IFDS problem can be converted into an equivalent IDE problem~\cite{reps1995precise}. The equivalent problem can be solved by the IDE algorithm, and the result converted into an IFDS result. In~an~IFDS-equivalent IDE problem, the~graph~$G^*$ and the~set~$D$ of~data-flow facts remain the~same. The $L$ lattice is a two-point lattice: if a fact is mapped to the top (bottom) element, then it is reachable (unreachable). The conversion between IFDS and IDE problems is discussed in detail in Section~\ref{seq:transIfdsIde}.
}

\commentout{
\subsubsection{Environment Transformers}
For each node in the control-flow graph, the result of an IDE analysis computes an environment $\textsf{Env}(D,\,L)$, which is a map from data-flow facts to lattice elements.

Instead of flow functions that show how to propagate facts, the IDE framework uses distributive environment transformers to propagate environments. For each edge $(n_1,\,n_2)$ in the control-flow supergraph, an environment transformer indicates how the environment at node $n_1$ is modified at node $n_2$.

From Section~\ref{sec:overviewifds} we know that flow functions can be represented with exploded-graph edges. To represent environment transformers, we will construct \textit{labeled} exploded-graph edges, where each edge is associated with a distributive \textit{micro function}%
\footnote{See~Sagiv et al.~\cite{sagiv1996precise} for a formal definition of the representation relation for environment transformers.}
$f:\,L\to L$. A~micro function shows how to change a lattice element for a given node and fact.

For instance, if an IDE problem is equivalent to an IFDS problem, the edges of the exploded supergraph are the same for both problems. In the IDE problem, the edges of the exploded supergraph are labeled with identity micro functions.

We extend the meet operator to work on micro functions by defining
\begin{equation}
  (f_1\sqcap f_2)(l)=f_1(l)\sqcap f_2(l)
\end{equation}
for all $l\in L$.
}

%In IDE problems, the auxiliary fact analogous to $\mathbf0$ in IFDS is denoted as $\Lambda$.

\commentout{
\begin{mdelete}
\begin{example}\label{ex:constprop}
  One version of the constant propagation analysis that can be encoded with IDE is \textit{linear constant propagation}. A linear constant propagation analysis can detect constants of the form $a\cdot x+b$, where $a$ and $b$ are integers and $x$ is a variable. In particular, a variable can only be considered constant if it depends on at most one other constant variable: even if $y$ and $z$ are variables that are considered constant, the variable $x=y+z$ will be considered not constant. If we encoded the analysis in a way to handle non-linear constant assignments, we would have to use non-distributive flow functions, which would violate the requirements of the IDE algorithm.
  
  For linear constant propagation, the $L$ lattice consists of the set of integers $\mathbb Z$, a top element denoting ``not a constant'', and a bottom element denoting an unknown value.
  The meet of two lattice elements is defined as follows: for any lattice element $l\in L$,
  \[
    \top\sqcap l=\top\qquad\text{and}\qquad\bot\sqcap l=l.
  \]
  For two lattice elements $l_1,\,l_2\in\mathbb Z$, $$l_1\sqcap l_2=\top.$$
  
  We define the addition and multiplication operations on lattice elements $l\in L$ and integers $c\in\mathbb Z$ as follows:
  \[
    l+c=\begin{cases}
      \bot&\text{if }l=\bot;\\
      \top&\text{if }l=\top;\\
      l+c&\text{otherwise.}
    \end{cases}
    \qquad
    c\cdot l=\begin{cases}
      \bot&\text{if }l=\bot;\\
      \top&\text{if }l=\top;\\
      c\cdot l&\text{otherwise.}
    \end{cases}
  \]
   Let the function $M$ that maps supergraph edges to environment transformers be defined in the following way:
  \[
    M=\lambda((n_1,\,n_2))\,.\,
    \begin{cases}
      \lambda\textsf{env}\,.\,\textsf{env}[x\to a\cdot\textsf{env}(y)+c\,]
        &\text{if $n_1$ contains an assignment}\\&\text{$x=a\cdot y+c$, where $y$ is a variable}\\&\text{and $a,\,c$ are constants;}\\
      \id
        &\text{otherwise.}
    \end{cases}
  \]
  Here, we denote with $\textsf{env}[x\to a]$ an environment \textsf{env} in which the key $x$ is mapped to $a$, and all other keys $y\ne x$ are mapped to their old values $\textsf{env}(y)$.
  When $M$ is applied to an edge whose source node contains an assignment for a variable $x$, $M$ returns an environment transformer that updates the argument environment with a new value for $x$. 

  Consider the following program:

\inputMinted{java}{constprop.java}
  For the edges $e_1,\,e_2,\,e_3$, and $e_4$ that start at the first, second, third, and fourth instruction, $M$ creates the following environment transformers:
  \begin{align*}
    M(e_1)
    &=\lambda\textsf{env}\,.\,\textsf{env}[\texttt u\to 1]\\
    M(e_2)
    &=\lambda\textsf{env}\,.\,\textsf{env}[\texttt v\to\textsf{env}(\texttt u)+2]\\
    M(e_3)
    &=\lambda\textsf{env}\,.\,\textsf{env}[\texttt w\to\top]\\
    M(e_4)
    &=\lambda\textsf{env}\,.\,\textsf{env}[\texttt u\to 5].
  \end{align*}
  
  The corresponding labeled exploded supergraph is shown in Figure~\ref{fig:constprop}.
  
  The result of the analysis yields a map from nodes to environments. Each environment maps variables to elements of the constant-propagation lattice. The environment at the last node will look as follows:
  \[
    \{(\texttt u,\,5),\ (\texttt v,\,3),\ (\texttt w,\,\top)\}.
  \]
\end{example}

\begin{figure}
  \centering
    \tikzstyle{n}=[fill=black,circle,inner sep=1.5pt,sm]
    \tikzstyle{sm}=[font=\footnotesize]
\begin{tikzpicture}[>=stealth,on grid, auto]
    \node [n,label=$\Lambda$] (zero){};
    \node [n] (zero_) [below=\edge of zero] {};
    \node [n,label={\texttt u}] (u) [right=\dist of zero] {};
    \node [n] (u_) [below=\edge of u] {};
    \node [n,label={\texttt v}] (v) [right=\dist of u] {};
    \node [n] (v_) [below=\edge of v] {};
    \node [n,label=\texttt{w}] (w) [right=\dist of v] {};
    \node [n] (w_) [below=\edge of w] {};
    \node [n] (zero__) [below=\edge of zero_]{};
    \node [n] (u__) [below=\edge of u_]{};
    \node [n] (v__) [below=\edge of v_]{};
    \node [n] (w__) [below=\edge of w_]{};
    \node [n] (zero___) [below=\edge of zero__]{};
    \node [n] (u___) [below=\edge of u__]{};
    \node [n] (v___) [below=\edge of v__)]{};
    \node [n] (w___) [below=\edge of w__]{};  
    \node [n] (zero____) [below=\edge of zero___]{};
    \node [n] (u____) [below=\edge of u___]{};
    \node [n] (v____) [below=\edge of v___)]{};
    \node [n] (w____) [below=\edge of w___]{};     
    
    \path[->](zero) edge node[left,sm]{$\id$} (zero_);
    \path[->](zero) edge node[right,sm]{$\lambda l.1$} (u_);
    \path[->](zero_) edge node[left,sm]{$\id$} (zero__);
    \path[->](u_) edge node[right,sm]{$\lambda l.l+2$} (v__);
    \path[->](u_) edge node[left,sm]{$\id$} (u__);
    \path[->](zero__) edge node[left,sm]{$\id$} (zero___);
    \path[->](u__) edge node[left,sm]{$\id$} (u___);
    \path[->](v__) edge node[left,sm]{$\id$} (v___);
    
    \path[->,dashed,color=gray](v) edge node[left,sm]{$\id$} (v_);
    \path[->,dashed,color=gray](w) edge node[left,sm]{$\id$} (w_);
    \path[->,dashed,color=gray](w_) edge node[right,sm]{$\id$} (w__);
    
    \path[->] (zero___) edge node[left,sm]{$\id$} (zero____);
    \path[->] (u___) edge node[left,sm]{$\lambda l.5$} (u____);
    \path[->] (v___) edge node[left,sm]{$\id$} (v____);
    \path[->,dashed,color=gray] (w___) edge node[left,sm]{$\id$} (w____);
  \end{tikzpicture}
  \caption[A labeled exploded supergraph for a constant-propagation analysis described in Example~\ref{ex:constprop}]{A labeled exploded supergraph for a constant-propagation analysis described in Example~\ref{ex:constprop}. The dashed edges are edges not reachable from the entry node.}%
  \label{fig:constprop}%
  \end{figure}
\end{mdelete}
}
  
\commentout{
In this way, each edge in the exploded graph is labeled with a micro function. The mapping from exploded-graph edges to the corresponding micro functions is stored in \textit{edge functions},  denoted as \textsf{EdgeFn}$:\,E^\#\to(L\to L)$.
}

\subsubsection{Overview of the IDE Algorithm}\label{sec:ideoverview}
Just as any distributive function from $2^D$ to $2^D$ can be represented with a
representation relation, it is also possible to represent any distributive functions from
$\textsf{Env}(D,L)$
to
$\textsf{Env}(D,L)$
with a \textit{pointwise representation}. A pointwise representation is a bipartite graph
with the same nodes~\footnote{The IDE literature uses the symbol $\Lambda$ for the node that
    is denoted $\mathbf0$ in the IFDS literature.}
and edges as a representation relation, except that each edge is labelled
with a \textit{micro-function}, which is a function from $L$ to $L$. 
\commentout{
The pointwise representation of an environment transformer 
$t : \textsf{Env}(D,L) \to \textsf{Env}(D,L)$
is defined as
\newcommand{\microedge}[3]{#1\xrightarrow{#3}#2}
\begin{align*}
    R_t =& \{ \microedge{\Lambda}{\Lambda}{\lambda l.l} \} \cup
    \{\microedge{\Lambda}{d_j}{\lambda l.t(\Omega)(d_j)} \mid d_j \in D\}\\
    &\cup
    \{\microedge{d_i}{d_j}{\lambda l.t(\Omega[d_i\to l])(d_j)} \mid d_i, d_j \in D\}.
\end{align*}
}
Let $\Omega = \lambda d.\top$ be the environment that maps every element of $D$ to $\top$.
Thanks to distributivity, every environment transformer 
$t : \textsf{Env}(D,L) \to \textsf{Env}(D,L)$
can be decomposed into its effect on $\Omega$ and on a set of environments $\Omega[d_i\to l]$
that map every element except one ($d_i$) to $\top$:
\[
    t(m)(d_j) = \lambda l. t(\Omega)(d_j) \sqcap \bigsqcap_{d_i\in D} \lambda l. t(\Omega[d_i\to l])(d_j).
\]
The functions $\lambda l. \cdots$ in this decomposition are the micro-functions that
appear on the edges of the pointwise representation edges from $\Lambda$ to each $d_j$ and from
each $d_i$ to each $d_j$.%
\footnote{The IDE paper defines a more complicated but equivalent set of micro-functions
that eliminate some duplication of computation.}
The absence of an edge in the pointwise representation from some $d_i$ to some $d_j$ is
equivalent to an edge with micro-function $\lambda l.\top$.

\otodo{Discuss the micro-functions in the example exploded supergraph in Figure 3.}

The meet of two environment transformers $t_1, t_2$ can be computed by taking the union of the edges
in their pointwise representations. When the same edge appears in the pointwise representations of
both $t_1$ and $t_2$, the micro-function for that edge in $t_1 \sqcap t_2$ is the meet of the
micro-functions for that same edge in $t_1$ and in $t_2$.

The composition of two environment transformers can be computed by combining their pointwise
representation graphs in the same way as IFDS representation relations, and 
computing the composition of the micro-functions appearing along each path in the resulting graph.

The IDE algorithm operates on the same exploded supergraph as the IFDS algorithm
(except that the edges are labelled with micro-functions). For each pair $(n,d)$ of
node and fact, the algorithm computes a micro-function equal to the meet of the micro-functions
of all the realizable paths from the program entry point to the pair.

In order to do this efficiently, the IDE algorithm requires a representation of micro-functions
that is general enough to express the basic micro-functions of the dataflow functions for individual
instructions, and that supports computing the meet and composition of micro-functions.


Similar to the IFDS algorithm, a practical implementation of the IDE algorithm requires
the input dataflow functions to be provided in their pointwise representation
as exploded supergraph edges labelled with micro-functions. Specifically,
the input is generally provided as a function $f: N^* \times D \times N^* \to (D \to F)$,
where $F$ is the set of representations of micro-functions from $L$ to $L$.
Given a (non-exploded) supergraph edge $n \to n'$ and a dataflow fact $d$,
$f(n,d,n')$ returns a map that gives for each fact $d'$ the micro-function $f$
that appears on the exploded supergraph edge $(n,d) \to (n',d')$.
Like in the IFDS algorithm, the function $f$ can be split up into separate functions that handle the cases when
the $n\to n'$ is an intraprocedural edge, a call-to-start edge, or an end-to-return edge.


\otodo{In the next section, we talk about \textsf{EdgeFn}, which is inconsistent with how
    we define the functions to be implemented here. We need to make the two sections consistent,
    one way or the other.}

\commentout{
Given a labeled exploded supergraph, the IDE algorithm computes the environments for all nodes in the control-flow graph.

The algorithm first computes the lattice elements $l_{n,\,d}$ that correspond to each reachable node $(n,\,d)$ in the exploded supergraph. The union of the exploded nodes $(n,\,d)$ for a given control-flow node $n$, mapped to the corresponding lattice elements $l_{n,\,d}$, form the environment $\textsf{Env}_n$  for that node:
\begin{equation}
  \textsf{Env}_n=\left\{(d,\,l_{n,\,d})\ |\ (n,\,d)\in N^\#\right\}\,.
\end{equation}

\mtodo{I think the rest of this section will not make sense to anyone who does not already understand it. Should I try to replace it with one paragraph that tries to give an intuitive understanding of what the IDE algorithm is doing?}
The overall idea behind computing the lattice elements $l_{n,\,d}$ is the following. For each inter-procedurally realizable path
\[
  p=\left[(\startmain,\,\Lambda),\,(n_1,\,d_1),\,\dots,\,(n_k,\,d_k)\right]
\]
 that starts with the entrypoint of the exploded supergraph, we compute the micro function $f_p$ that corresponds to $p$. The micro function consists of the composition of all individual micro functions with which the edges of $p$ are labeled:
\begin{align}
  f_p=\textsf{EdgeFn}((n_{k-1},\,d_{k-1}),\,(n_k,\,d_k))\,\circ\ldots\circ
      \textsf{EdgeFn}(\startmain,\,\Lambda),\,(n_1,\,d_1))\,.
\end{align}

Let the lattice element that $(n,\,d)$ is mapped to according to path $p$ be denoted as $l_{n,\,d}^p$. As shown in~Sagiv et al.~\cite{sagiv1996precise}, the lattice element can be obtained by applying $f_p$ to the bottom element:
\begin{equation}
 l^p_{n,\,d}=f_p(\bot)\,.
\end{equation}

Let $Q$ be the set of paths that start at the entry point and end at the given node $(n,\,d)$.
The lattice element $l_{n,\,d}$ is the meet of the lattice elements corresponding to all the paths in $Q$:
\[
  l_{n,\,d}=\bigsqcap_{q\in Q}l^q_{n,\,d}\,.
\]

This is a general outline of the IDE analysis. We use the IDE framework to improve the precision of IFDS problems in the presence of correlated calls.
The next section describes how this is done.
}
