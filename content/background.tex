\section{Background}\label{sec:bg}
The purpose of the correlated-calls analysis is to solve IFDS problems more precisely than using the standard IFDS algorithm by ruling out some infeasible paths. The correlated-calls analysis works by transforming an IFDS problem to an IDE problem, solving the IDE problem, and transforming the IDE result to a solution to the original IFDS problem. This section describes the general ideas underlying IFDS and IDE.

\subsection{Related Work}
IFDS is a version of the functional approach to data-flow analysis developed by M.\,Sharir and A.\,Pnueli~\cite{pnueli1981two}. Their algorithm is based on computing \textit{summary functions} that return the data-flow value at the end of a procedure, given the data-flow value at the start of the procedure. IFDS problems form a more restricted set of data-flow problems: unlike in the functional approach, IFDS flow functions have to be distributive, and the set of data-flow facts $D$ has to be finite. However, the IFDS algorithm is more general than Sharir's and Pnueli's algorithm in that it can handle programs containing local variables and parameters in recursive methods.

IFDS has been used to encode a variety of data-flow problems. More complex examples of applications include typestate analysis (determining which operations can be performed on an object at a given program point)~\cite{naeem2008typestate} or shape analysis (detecting errors and validating properties of programs at compile time)~\cite{DBLP:conf/birthday/KreikerRRSWY13}.

IFDS is implemented for two popular static-analysis frameworks, the T.J. Watson Libraries for Analysis (WALA)~\cite{fink2012wala} and Soot~\cite{vallee1999soot}.

WALA is a framework for static analysis on Java bytecode developed by the IBM T.J.~Watson Research Center.
In the implementation of our work, we use WALA to build and traverse the supergraph (a special kind of control-flow graph) of a Java program\footnote{However, we do not use WALA's IFDS implementation, as explained in~Section~\ref{chapter:eval}.}.

Soot is a framework for program analysis and optimization on Java bytecode, developed by the Sable Research Group at McGill University. Unlike WALA, Soot also has an implementation of the IDE algorithm. The IFDS and IDE implementations for Soot are part of the Heros project~\cite{bodden2012inter}.

Whereas one advantage of Soot's IFDS implementation (and other static analysis tools) is ease of use and extensibility, WALA's primary focus is efficiency. For example, WALA uses bit-vectors to represent some of the analysis data types, like local variables and parameters. Another difference is that WALA's intermediate representation of a program uses static single assignment (SSA) form~\cite{cytron1991efficiently}. SSA form is a representation of the program in which each variable has only one definition (assignment). SSA can make dataflow analysis simpler and more efficient~\cite{appel1998ssa}.

Work on improving the IFDS algorithm includes Practical Extensions by~N.\,Naeem and O.\,Lhot\'ak~\cite{naeem2010pei}. Their paper presents four extensions to the IFDS algorithm. Two of the extensions improve the efficiency of the IFDS analysis for certain classes of IFDS problems. Another extension widens the class of problems applicable for the IFDS analysis. However, those extensions do not affect the precision of IFDS problems. Our analysis, in contrast, does not improve the efficiency or generality of IFDS, but it allows us to solve IFDS problems more precisely.

The fourth extension is targeted towards programs that are represented in SSA form. Executing the IFDS analysis on such programs results in loss of precision in the presence of control-flow constructs (e.g. conditionals and loops), compared to programs in non-SSA form.
The extension makes the IFDS analysis on programs in SSA form as precise as on programs that are not represented in SSA form. In contrast, the correlated-calls analysis is applicable to programs in both SSA and non-SSA forms. Even if applied to a program in SSA form, our analysis and the extension improve the precision of IFDS in unrelated situations: the first analysis handles correlated calls, and the latter handles control-flow constructs. Thus, an IFDS analysis could benefit from both precision improvements independently.

Another work on improving the efficiency of the IFDS algorithm is E.\,Bodden et~al.'s framework for the analysis of software products lines~\cite{bodden2013spl}. Their paper uses transformations from IFDS to IDE problems, a technique we also employ. Finally, J.\,Rodriguez and O.\,Lhot\'ak implemented a concurrent version of the IFDS algorithm using actors~\cite{rodriguez2010concurrent}. However, neither of those works is concerned with improving the precision of IFDS results.

The correlated-calls analysis improves the precision of a data-flow analysis by eliminating a special type of infeasible paths. This is similar to the idea of context-sensitive analysis: just as a context-sensitive analysis eliminates infeasible paths from the end of a procedure to the call sites that do not match the given procedure call, the correlated-calls analysis eliminates infeasible paths caused by correlated method calls.

The idea of using correlated calls to remove infeasible paths in data-flow analyses of object-oriented programs was introduced by F.\,Tip~\cite{frank2014correlated}. The possibility of using IDE to achieve this is mentioned, but not elaborated upon. Our work presents a concrete solution to the problem and an implementation of that solution.

The idea of eliminating infeasible paths caused by correlated calls is similar to M.~Sridharan et~al.'s work on improving the precision of pointer analysis for JavaScript programs~\cite{DBLP:conf/ecoop/SridharanDCST12}. For each pointer, a pointer analysis determines the possible set of objects (the \textit{points-to} set) that the pointer can reference at a given program point. In JavaScript, it is challenging to compute the points-to set of fields because in general, field names can be derived from arbitrary expressions and bound at runtime.
As a result, an imprecise data-flow analysis will include infeasible paths between values of the form \verb'o[p]' (access of a property \verb'p' of object \verb'o'), where at compile time, \verb'p' can be bound to different values.
The idea of the paper is to track all dynamic property accesses (reads and writes) on an object \verb'o' with property name \verb'p'. The code snippets containing the references \verb'o[p]' are then extracted into a separate function $f$. The analysis is then run so that for each possible value of \verb'p', $f$ is analyzed separately; therefore, for a given property name, all correlated objects with that name are analyzed together.

The differences between this method of tracking correlated calls and our analysis are the following.
\begin{itemize}
  \item \textit{Type of target data-flow analysis} whose precision is to be improved. Our analysis improves the precision of IFDS data-flow analyses, whereas the JavaScript analysis improves the precision of pointer analysis.
  \item \textit{Target language}. Our analysis is for object-oriented languages where polymorphic methods, and not property names (which are known at compile time), cause infeasible paths.
  \item \textit{Different handling of correlated calls}. Extracting code that contains correlated calls into separate methods would not prevent infeasible paths. Instead, our analysis uses IDE flow functions to detect and eliminate infeasible paths caused by correlated calls.
\end{itemize}



\subsection{Terminology and Notation}
We will start by introducing several concepts used by the IFDS and IDE analyses.

A \textit{control-flow graph} is a directed graph in which nodes correspond to instructions and edges represent transfer of control between the instructions during an execution of the program. 
A control-flow graph has a unique start node, $\startmain$, which is the node corresponding to the program entrypoint.

An \textit{intra-procedural} path is a path in a control-flow graph whose nodes are in the same procedure. By contrast, an \textit{inter-procedural path} is one that contains nodes from different procedures. 

A \textit{control-flow supergraph} is a control-flow graph
in which each procedure $p$ is augmented with an additional \textit{start node} \textsf{start}$_p$ and \textit{end node} \textsf{end}$_p$, and for each call $c_q$ to a procedure $q$, there is a \textit{call node} \textsf{call}$_{c_q}$ and subsequent \textit{return node} \textsf{return}$_{c_q}$.

A control-flow supergraph allows us to model the control flow in inter-procedural paths.
 The flow from the caller to the callee is represented using an edge \[(\textsf{call}_{c_q},\,\textsf{start}_q)\,.\] The control flow from the callee back to the caller goes through an edge \[(\textsf{end}_q,\,\textsf{return}_{c_q})\,.\]

\begin{example}
  Consider the program in Listing~\ref{list:examplejava}. The supergraph corresponding to that program is shown in Figure~\ref{fig:examplesupergraph}.
\begin{figure}
  \centering
  \begin{minipage}{\textwidth}
    \inputMinted{java}{examplesupergraph.java}
  \end{minipage}
  \caption{An example Java program}
  \label{list:examplejava}
\end{figure}
  
  \begin{figure}%
  \centering
  \scalebox{.9}{
      \tikzset{
        ashadow/.style={
          opacity=.25,
          shadow xshift=0.07,
          shadow yshift=-0.07
        },
      }
    \tikzstyle{supergraph}=[
      fill=greyblue,
      rounded corners,
      font=\small,
      align=center,
      text=charcoal,
      drop shadow={ashadow, color=greyblue}
    ]
    \tikzstyle{supergraph_s}=[
      fill=bisque,
      rounded corners,
      font=\small,
      align=center,
      text=charcoal,
      drop shadow={ashadow, color=greyblue}
    ]
    \tikzstyle{supergraph_f}=[
      fill=lightsalmonpink,
      rounded corners,
      font=\small,
      align=center,
      text=charcoal,
      drop shadow={ashadow, color=greyblue}
    ]
    \tikzstyle{description}=[fill=white]
\begin{tikzpicture}

% main method nodes
    \node [supergraph] (st_main) {\textsf{start}$_{\texttt{main}}$};
    \node [supergraph] (call_secret) [below = \dist of st_main.south] {\textsf{call}$_\texttt{secret}$};
    \node [supergraph] (return_secret) [below = \dist of call_secret.south] {\textsf{return}$_\texttt{secret}$\\\texttt{a = secret()}};
    \node [supergraph] (call_f_main) [below = \dist of return_secret.south] {\textsf{call}$_\texttt{A.f}$};
    \node [supergraph] (return_f_main) [below = \dist of call_f_main.south] {\textsf{return}$_\texttt{A.f}$\\\texttt{b = f(a)}};
    \node [supergraph] (end_main) [below = \dist of return_f_main.south] {\textsf{end}$_{\texttt{main}}$};
% main method edges
    \path[->] (st_main) edge (call_secret);
    \path[->] (call_secret) edge (return_secret);
    \path[->] (return_secret) edge (call_f_main);
    \path[->] (call_f_main) edge (return_f_main);
    \path[->] (return_f_main) edge (end_main);
    
%secret method nodes
    \node [supergraph_s] (st_secret) [above right = 2*\dist and 6*\dist of st_main] {\textsf{start}$_{\texttt{secret}}$};
    \node [supergraph_s] (return_secret_string) [below = \dist of st_secret.south] {\texttt{return "secret"}};
    \node [supergraph_s] (end_secret) [below = \dist of return_secret_string.south] {\textsf{end}$_\texttt{secret}$};
%secret method edges
    \path[dashed,->] (call_secret) edge[out=20,in=130,->] (st_secret);
    \path[->] (st_secret) edge (return_secret_string);
    \path[->] (return_secret_string) edge (end_secret);
    \path[dashed,->] (end_secret) edge[out=240,in=5] (return_secret);

%f method nodes
    \node [supergraph_f] (st_f) [below right = 2*\dist and \dist of end_secret.south] {\textsf{start}$_\texttt f$};
    \node [supergraph_f] (if) [below = \dist of st_f.south] {\texttt{if (s == null)}};
    \node [supergraph_f] (return_x) [below right = \dist and 2*\dist of if.south] {\texttt{return s}};
    \node [supergraph_f] (call_f_f) [below left = \dist and 2*\dist of if.south] {\textsf{call}$_\texttt{f}$};
    \node [supergraph_f] (return_f_f) [below = \dist of call_f_f.south] {\textsf{return}$_\texttt{f}$\\\texttt{r = f("not secret")}};
    \node [supergraph_f] (return_r) [below = \dist of return_f_f.south] {\texttt{return r}};
    \node [supergraph_f] (end_f) [below right = \dist and 2*\dist of return_r.south] {\textsf{end}$_\texttt f$};
%f method edges
    \path[dashed,->] (call_f_main) edge[out=0,in=160] (st_f);
    \draw[->] (st_f) edge (if);
    \draw[->] (if) edge [out=210,in=45] (call_f_f);
    \draw[->] (call_f_f) edge (return_f_f);
    \draw[dashed,->] (call_f_f) [out=170,in=200] edge (st_f);
    \draw[->] (return_f_f) edge (return_r);
    \draw[->] (return_r) edge [out=-80,in=175] (end_f);
    \draw[->] (if) edge [out=330,in=135] (return_x);
    \draw[->] (return_x) edge [out=270,in=10] (end_f);
    \draw[dashed,->] (end_f) edge [out=200,in=180] (return_f_f);
    \draw[dashed,->] (end_f) edge [out=215,in=-50] (return_f_main);
    
%arrow description
    \node [description] (intra_arrow_left) [above right = \dist and 2*\dist of st_secret] {};
    \node [description] (intra_arrow_right) [right = \dist of intra_arrow_left] {};
    \node [description] (inter_arrow_left) [below = .5*\dist of intra_arrow_left] {};
    \node [description] (inter_arrow_right) [below = .5*\dist of intra_arrow_right] {};
    \path[->](intra_arrow_left) edge node[right = .5*\dist]{intra-procedural edge} (intra_arrow_right);
    \path[dashed,->](inter_arrow_left) edge node[right = .5*\dist]{inter-procedural edge} (inter_arrow_right);
\end{tikzpicture}
}
  \caption{An example supergraph for Listing~\ref{list:examplejava}}%
  \label{fig:examplesupergraph}%
  \end{figure}
\end{example}

A \textit{flow-sensitive} data-flow analysis is one that takes the order of program instructions into account.

Let each call node in a program be labeled with a distinct opening parenthesis and the corresponding return node with the matching closing parenthesis. For a given path $p$, let $s$ be the string that is obtained by concatenating the labels of the nodes in $p$.
Then $p$ is \textit{valid} if $s$ belongs to the language of substrings of balanced parentheses. The set of all inter-procedurally valid paths from the start node to a node $n$ is denoted as $\ivp(n)$. The set $\ivp(n)$ is a conservative approximation of all concrete execution paths from the start node to $n$.

A \textit{context-sensitive} data-flow analysis is an analysis that considers only inter-procedurally valid paths.

\begin{example}
  In the supergraph in Figure~\ref{fig:examplesupergraph}, let us assign $\{,\,\}$ parentheses to $\textsf{call}_\texttt{A.f}$ and $\textsf{return}_\texttt{A.f}$, and $\langle,\,\rangle$ parentheses to $\textsf{call}_\texttt{f}$ and $\textsf{return}_\texttt{f}$. 
  Then the string corresponding to the path 
  \[
    p_1=\left[\highlight{\textsf{call}_\texttt{A.f}}{greyblue},\,
          \highlight{\textsf{start}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\texttt{if (s == null)}}{lightsalmonpink},\,
          \highlight{\texttt{return s}}{lightsalmonpink},\,
          \highlight{\textsf{end}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\textsf{return}_\texttt{A.f}}{greyblue}
    \right]
  \]
  is $\{\}$, which indicates that $p_1$ is valid. Every prefix of $p_1$ is also a valid path.
  
However, the graph also contains an inter-procedurally invalid path
  \[
    p_2=\left[\highlight{\textsf{call}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\textsf{start}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\texttt{if (s == null)}}{lightsalmonpink},\,
          \highlight{\texttt{return s}}{lightsalmonpink},\,
          \highlight{\textsf{end}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\textsf{return}_\texttt{A.f}}{greyblue}
    \right]
  \]
  with corresponding string $\langle\}$.
\end{example}

A \textit{lattice} is a partially ordered set in which each subset has a least upper bound and a greatest lower bound.

A \textit{meet semilattice} $L=(S,\,\sqcap)$ is defined by a set $S$ and a meet operation $\sqcap$ that is  associative, commutative, and idempotent.
  The meet operation induces a partial order $(S,\,\sqsubseteq)$ where every subset contains  a greatest lower bound: For all $x,\,y\in S$, $x\sqsubseteq y$ if $x\sqcap y=x$. The greatest lower bound, or top element, of the semilattice is denoted as $\top$.
  If $k$ is the length of the longest chains of elements in the semilattice, then the \textit{height} of the semilattice is~$k-1$.

Finally, we introduce the notion of \textit{distributivity}. Given a set $D$, a function $f:2^D\to2^D$ is distributive if $\forall x_1,\,x_2\in 2^D$,
\begin{equation}
  f(x_1\cup x_2)=f(x_1)\cup f(x_2).
\end{equation}

In this work, we will denote a map from a set of keys $K$ to values from set $V$ as
\begin{equation}
  \{(k,\,v)\,|\,k\in K,\,v\in V\}.
\end{equation}
For an arbitrary map $m$,  $m(x)$ is the value to which $x$ is mapped in $m$. We denote by $m[x\to y]$ a map identical to $m$, except that the element $x$ is mapped to $y$.
To avoid excessive parentheses, we write $\left(m[x_1\to y_1]\right)[x_2\to y_2]$ as $m[x_1\to y_1][x_2\to y_2]$.

We will denote the identity function $\lambda x\,.x$ by $\textsf{id}$.
We will use a typed version of this function in various contexts, where the type of $x$ will vary with
the context.


\subsection{IFDS}\label{sec:bgifds}
The purpose of the IFDS framework is to solve a special subset of inter-procedural, flow-sensitive, context-sensitive data-flow-analysis problems. The main idea of IFDS is to encode the data-flow analysis problem into a graph-reachability problem.

\subsubsection{Data-Flow Problems Suitable for IFDS}\label{sec:suitableifds}
In this section we describe the data-flow problems that can be solved by an IFDS analysis. We will start with an intuitive definition and later on formalize the notion of an IFDS-suitable problem.

Informally, an IFDS analysis can only solve decision problems. An IFDS analysis answers questions of the following kind: ``is property $X$ true at program point~$Y$?''. For example, a taint-analysis problem asks, for each variable $v$ in the program, ``is $v$ secret at a given program point?''. 
An available-expressions problem asks, for each expression $e$, ``does $e$ have to be recomputed at a given program point?''.

Formally, a data-flow analysis problem is suitable for an IFDS analysis if it can be encoded as an IFDS problem
\begin{equation}
  G^*,\,D,\,F,\,M_F,\,\sqcap)\,,
\end{equation} where $G^*=(N^*,\,E^*)$ is the supergraph of the input program with nodes $N^*$ and edges $E^*$, $D$ is a finite set of \textit{data-flow facts}, $F$ is a set of distributive dataflow functions of type $2^D\to2^D$, $M_F:\,E^*\to F$ is a function that maps supergraph edges to dataflow functions, and $M_F$ is extended to paths by composition\footnote{%
  Let $A$ be a set and $f:\,E^*\to(A\to A)$ a function from supergraph edges to functions on $A$.
  We say that $f$ is extended to  paths by composition to denote that for a path $q$ consisting of the edges $e_1,\,\dots,\,e_k$, $f(q)=f(e_k)\circ\ldots\circ f(e_1)\circ\id$.
}. The \textit{meet operator} $\sqcap$ is either union or intersection.

Without loss of generality, we will take meet to denote union. It can be shown that any problem where meet is defined as intersection can be reformulated into an equivalent one where meet is defined as union~\cite{reps1995precise}.

\subsubsection{Overview of the IFDS Algorithm}\label{sec:overviewifds}
Formally, given an IFDS problem, for each node $n\in N^*$ the IFDS algorithm computes the \textit{meet-over-all-valid-paths} solution
\begin{equation}
 \mvp{F}(n)=\bigsqcap_{q\in\ivp(n)}M_F(q)(\varnothing)\,.
\end{equation}

To compute the meet-over-all-valid-paths solution, each node in the control-flow supergraph is paired with a \textit{fact} $d\in D\cup\{\mathbf0\},\,\mathbf0\notin D$, yielding the nodes $N^\#$ of the \textit{exploded supergraph} $G^\#=(N^\#,\,E^\#)$.
Roughly, for each node in the program, a fact denotes a binary property whose value (true or false) we want to find out.
The start node of the exploded supergraph is the node $(\startmain,\,\mathbf0)$.

The flow functions $F$ define the edges of the exploded supergraph.
Using the flow functions, the IFDS algorithm computes the inter-procedurally \textit{realizable} paths from the start to the rest of the exploded graph's nodes. A realizable path is a valid path in the exploded supergraph that starts with the entry node $\startmain$.

If there is a realizable path from the node $(\startmain,\,\mathbf0)$ to a given node $(n,\,d),\,d\ne\mathbf0$, then the fact $d$ is considered to hold at node $n$. A path to a node $(n,\,\mathbf0)$ means that in the control-flow supergraph, there is a path from $\startmain$ to $n$.

In this way, the IFDS algorithm reduces the input data-flow problem to a graph-reachability problem.
\begin{example}
  In a taint analysis, $D$ is the set of variables in the program. If a fact $d\in D$ is reachable at a given node, then the variable is considered secret at that node. Otherwise, it is considered not secret. The question ``is $d$ secret at node $n$?'' becomes ``is there a realizable path from (\textsf{start}$_\texttt{main}$,\,\textbf{0}) to $(n,\,d)$?''.
\end{example}
\begin{example} 
  In an available-expressions analysis, $D$ is the set of all expressions in the program. If an expression $d\in D$ is reachable at a certain node, it means that it does not need to be recomputed at that node. 
\end{example}
\begin{example}
  The exploded supergraph for Listing~\ref{list:examplejava} is shown in Figure~\ref{fig:exampleexploded}.
  We can see that there is a realizable path
  from the start node of the exploded graph to the variable \verb'b' at~the~node~$\textsf{return}_\texttt{A.f}$ in the \verb'main' method. This means that at that node, \verb'b' is considered secret.
  
    \begin{figure}%
      \hspace*{-30pt}
\scalebox{.9}{
      \tikzset{
        ashadow/.style={
          opacity=.25,
          shadow xshift=0.07,
          shadow yshift=-0.07
        },
      }
    \tikzstyle{supergraph}=[
      fill=greyblue,
      rounded corners,
      font=\small,
      align=right,
      text=charcoal,
      drop shadow={ashadow, color=greyblue}
    ]
    \tikzstyle{supergraph_s}=[
      fill=bisque,
      rounded corners,
      font=\small,
      align=left,
      text=charcoal,
      drop shadow={ashadow, color=greyblue}
    ]
    \tikzstyle{supergraph_f}=[
      fill=lightsalmonpink,
      rounded corners,
      font=\small,
      align=left,
      text=charcoal,
      drop shadow={ashadow, color=greyblue}
    ]
    \tikzstyle{description}=[fill=white]
    \tikzstyle{n}=[fill=black,circle,inner sep=1.5pt]
    
\begin{tikzpicture}[>=stealth,on grid, auto]

% main method nodes
    \node [supergraph] (st_main) {\textsf{start}$_{\texttt{main}}$};
    \node [supergraph] (call_secret) [below = \dist of st_main.south east, anchor=east] {\textsf{call}$_\texttt{secret}$};
    \node [supergraph] (return_secret) [below = \dist of call_secret.south east,anchor=east] {\textsf{return}$_\texttt{secret}$\\\texttt{a = secret()}};
    \node [supergraph] (call_f_main) [below = \dist of return_secret.south east, anchor=east] {\textsf{call}$_\texttt{A.f}$};
    \node [supergraph] (return_f_main) [below = \dist of call_f_main.south east, anchor=east] {\textsf{return}$_\texttt{A.f}$\\\texttt{b = f(a)}};
    \node [supergraph] (end_main) [below = \dist of return_f_main.south east, anchor=east] {\textsf{end}$_{\texttt{main}}$};
    
    \node [n,label=$\mathbf{0}$] (st_main_z) [right=\ndd of st_main.east] {};
    \node [n,label=\texttt{a}] (st_main_x) [right=\ndd of st_main_z] {};
    \node [n,label=\texttt{b}] (st_main_y) [right=\ndd of st_main_x] {};
    
    \node [n] (call_secret_z) [right=\ndd of call_secret.east] {};
    \node [n] (call_secret_x) [right=\ndd of call_secret_z] {};
    \node [n] (call_secret_y) [right=\ndd of call_secret_x] {};
    
    \node [n] (return_secret_z) [right=\ndd of return_secret.east] {};
    \node [n] (return_secret_x) [right=\ndd of return_secret_z] {};
    \node [n] (return_secret_y) [right=\ndd of return_secret_x] {};
    
    \node [n] (call_f_main_z) [right=\ndd of call_f_main.east] {};
    \node [n] (call_f_main_x) [right=\ndd of call_f_main_z] {};
    \node [n] (call_f_main_y) [right=\ndd of call_f_main_x] {};
    
    \node [n] (return_f_main_z) [right=\ndd of return_f_main.east] {};
    \node [n] (return_f_main_x) [right=\ndd of return_f_main_z] {};
    \node [n] (return_f_main_y) [right=\ndd of return_f_main_x] {};
    
    \node [n] (end_main_z) [right=\ndd of end_main.east] {};
    \node [n] (end_main_x) [right=\ndd of end_main_z] {};
    \node [n] (end_main_y) [right=\ndd of end_main_x] {};
% main method edges
    \path[->](st_main_z) edge (call_secret_z);
    \path[->](call_secret_z) edge (return_secret_z);
    \path[->](return_secret_z) edge (call_f_main_z);
    \path[->](call_f_main_z) edge (return_f_main_z);
    \path[->](return_f_main_z) edge (end_main_z);  
    \path[->](return_f_main_y) edge (end_main_y);    
    
%secret method nodes
    \node [supergraph_s] (st_secret) [above right = 2*\dist and 6*\dist of st_main] {\textsf{start}$_{\texttt{secret}}$};
    \node [supergraph_s] (return_secret_string) [below = \dist of st_secret.south west, anchor=west] {\texttt{return "secret"}};
    \node [supergraph_s] (end_secret) [below = \dist of return_secret_string.south west,anchor = west] {\textsf{end}$_\texttt{secret}$};
    
    \node [n,label=$\mathbf{0}$] (st_secret_z) [left=\ndd of st_secret.west] {};
    \node [n] (return_secret_string_z) [left=\ndd of return_secret_string.west] {};
    \node [n] (end_secret_z) [left=\ndd of end_secret.west] {};
%secret method edges
    \path[->](st_secret_z) edge (return_secret_string_z); 
    \path[->](return_secret_string_z) edge (end_secret_z); 
    \path[->,dashed](call_secret_z) edge [out=30,in=180] (st_secret_z);
    \path[->,dashed](end_secret_z) edge [out=240,in=40] (return_secret_z);
    \path[->,dashed](end_secret_z) edge [out=260,in=30] (return_secret_x);
    \path[->](return_secret_x) edge (call_f_main_x);
    \path[->](call_f_main_x) edge (return_f_main_x);
    \path[->](return_f_main_x) edge (end_main_x);

%f method nodes
    \node [supergraph_f] (st_f) [below=2*\dist of end_secret.south west,anchor=west] {\textsf{start}$_\texttt f$};
    \node [supergraph_f] (if) [below = \dist of st_f.south west,anchor=west] {\texttt{if (s == null)}};
    \node [supergraph_f] (return_x) [below right = \dist and 2.5*\dist of if.south] {\texttt{return s}};
    \node [supergraph_f] (call_f_f) [below=\dist of if.south west,anchor=west] {\textsf{call}$_\texttt{f}$};
    \node [supergraph_f] (return_f_f) [below = \dist of call_f_f.south west,anchor=west] {\textsf{return}$_\texttt{f}$\\\texttt{r = f("not secret")}};
    \node [supergraph_f] (return_r) [below = \dist of return_f_f.south west,anchor=west] {\texttt{return r}};
    \node [supergraph_f] (end_f) [below=\dist of return_r.south west,anchor=west] {\textsf{end}$_\texttt f$};
   
     \node [n,label=\texttt{s}] (st_f_s) [left=\ndd of st_f.west] {}; 
     \node [n,label=\texttt{r}] (st_f_r) [left=\ndd of st_f_s] {};
     \node [n,label=$\mathbf{0}$] (st_f_z) [left=\ndd of st_f_r] {};
     
     \node [n] (if_s) [left=\ndd of if.west] {};
     \node [n] (if_r) [left=\ndd of if_s] {};
     \node [n] (if_z) [left=\ndd of if_r] {};
     
     \node [n] (call_f_f_s) [left=\ndd of call_f_f.west] {};
     \node [n] (call_f_f_r) [left=\ndd of call_f_f_s] {};
     \node [n] (call_f_f_z) [left=\ndd of call_f_f_r] {};
     
     \node [n] (return_f_f_s) [left=\ndd of return_f_f.west] {};
     \node [n] (return_f_f_r) [left=\ndd of return_f_f_s] {};
     \node [n] (return_f_f_z) [left=\ndd of return_f_f_r] {};
     
     \node [n] (return_r_s) [left=\ndd of return_r.west] {};
     \node [n] (return_r_r) [left=\ndd of return_r_s] {};
     \node [n] (return_r_z) [left=\ndd of return_r_r] {};
     
     \node [n] (end_f_s) [left=\ndd of end_f.west] {};
     \node [n] (end_f_r) [left=\ndd of end_f_s] {};
     \node [n] (end_f_z) [left=\ndd of end_f_r] {};
     
     \node [n,label=$\mathbf0$] (return_x_z) [right=\ndd of return_x.east] {};
     \node [n,label=\texttt{r}] (return_x_r) [right=\ndd of return_x_z] {};
     \node [n,label=\texttt{s}] (return_x_s) [right=\ndd of return_x_r] {};
%f method edges
    \path[->](st_f_z) edge (if_z);
    \path[->](if_z) edge (call_f_f_z);
    \path[->](call_f_f_z) edge (return_r_z);  
    \path[->](return_r_z) edge (end_f_z);
    \path[->](if_z) edge [out=-43,in=127] (return_x_z);
    \path[->](return_x_z) edge [out=270,in=25] (end_f_z);
    \path[->](st_f_s) edge (if_s);
    \path[->](if_s) edge (call_f_f_s);
    \path[->](call_f_f_s) edge (return_r_s);  
    \path[->](return_r_s) edge (end_f_s);
    \path[->](if_s) edge [out=-30,in=110] (return_x_s);
    \path[->](return_x_s) edge [out=270,in=25] (end_f_s);
    \path[->](return_f_f_r) edge (return_r_r);
    \path[->](return_r_r) edge (end_f_r);
    \path[->,dashed](call_f_main_z) edge [out=20,in=160] (st_f_z);
    \path[->,dashed](end_f_z) edge [out=150,in=-20] (return_f_main_z);
    \path[->,dashed](call_f_f_z) edge [out=110,in=250] (st_f_z);
    \path[->,dashed](end_f_z) edge [out=110,in=250] (return_f_f_z);
    \path[->,dashed](call_f_main_x) edge [out=32,in=112] (st_f_s);
    \path[->,dashed](end_f_s) edge [out=155,in=-40] (return_f_main_y);
    \path[->,dashed](end_f_s) edge [out=120,in=-50] (return_f_f_r);
    \path[->,dashed](end_f_r) edge [out=110,in=250] (return_f_f_r);
    \path[->,dashed](end_f_r) edge [out=150,in=-50] (return_f_main_y);
\end{tikzpicture}
}
  \caption{The exploded supergraph corresponding to a taint analysis for the input program in Listing~\ref{list:examplejava}}%
  \label{fig:exampleexploded}%
  \end{figure}
\end{example}

%\subsubsection{Flow Functions}\label{sec:flowfunifds}
The flow functions $F\subseteq 2^D\to2^D$ allow us to establish the edges in the exploded supergraph.

Given a control-flow-graph edge $e=(n_1,\,n_2)\in E^*$ and a distributive dataflow function $f=M(e)$, the \textit{representation relation} $R_f:\,(D\cup\{\mathbf0\})\times (D\cup\{\mathbf0\})$ of $f$ is defined as
\[
  R_f=\{(\mathbf0,\,\mathbf0)\}\cup
      \{(\mathbf0,\,d_j)\,|\,d_j\in f(\varnothing)\}\cup
      \{(d_i,\,d_j)\,|\,d_j\in f(\{d_i\}),\,d_j\notin f(\varnothing)\}.
\]
Each pair $(d_i,\,d_j)\in R_f$ corresponds to an edge $((n_1,\,d_i),\,(n_2,\,d_j))$ in the exploded supergraph.

Note that $R_f$ constructs pairs of dataflow facts so that
\begin{itemize}
  \item there is always an edge $(\mathbf0,\,\mathbf0)$ corresponding to the control-flow-graph edge;
  \item if there is an edge $(\mathbf0,\,d_j)$, then there is no other edge leading to $d_j$; in particular, there is never an edge $(d_i,\,\mathbf0)$ where $d_i\ne\mathbf0$.
\end{itemize}

\begin{example}\label{ex:flowfun}
  The representation relation $R_f$ for a set of data-flow facts $D=\{u,\,v,\,w\}$ and dataflow function $f=\lambda S\,.\,S\setminus\{v\}\cup\{u\}$ looks as follows:
  \[
    R_f=\{(\mathbf0,\,\mathbf0),\,(\mathbf0,\,u),\,(w,\,w)\}.
  \]  
  
The corresponding exploded-graph edges are shown below.
   \begin{center}
    \tikzstyle{n}=[fill=black,circle,inner sep=1.5pt]
\begin{tikzpicture}[>=stealth,on grid, auto]
    \node [n,label=$\mathbf{0}$] (zero){};
    \node [n,] (zero_) [below=\edge of zero] {};
    \node [n,label=$u$] (u) [right=\nd of zero] {};
    \node [n,] (u_) [below=\edge of u] {};
    \node [n,label=$v$] (v) [right=\nd of u] {};
    \node [n,] (v_) [below=\edge of v] {};
    \node [n,label=$w$] (w) [right=\nd of v] {};
    \node [n,] (w_) [below=\edge of w] {};
    \path[->](zero) edge (zero_);
    \path[->](zero) edge (u_);
    \path[->](w) edge (w_);
  \end{tikzpicture}
  \end{center}
\end{example}

The representation relation lets us decompose a flow function into functions that operate on each fact individually. This is possible due to distributivity: we can apply the flow function on each single fact and take the union of the results, rather than applying the function to the union of the facts.

The representation relation allows us to compactly represent the composition and meet operations which are required for the IFDS algorithm.

For two representation relations $R_{f_1},\,R_{f_2}$, the composition and meet operations are defined as follows:
\begin{align}
  R_{f_1}\circ R_{f_2}&=\{(d_1,\,d_3)\ |\ \exists d_2:\ (d_1,\,d_2)\in R_{f_1},\,(d_2,\,d_3)\in R_{f_2}\}\,.
\intertext{and}
  R_{f_1}\sqcap R_{f_2}&=R_{f_1}\cup R_{f_2}\,.
\end{align}

The representation relation distributes over composition and meet:
\begin{align}
  R_{f_1}\circ R_{f_2}=R_{f_1\circ f_2}\,,
\intertext{and}
  R_{f_1}\sqcap R_{f_2}=R_{f_1\sqcap f_2}\,.
\end{align}

On the exploded graph, the composition of two functions is represented by the paths that are formed when the exploded-graph edges are combined.

\begin{example}
  If $g=\lambda S\,.\,S\setminus\{w\}$ and $f$ is defined as in example~\ref{ex:flowfun}, then
  \[
    R_f\circ R_g=\{(\mathbf0,\,\mathbf0),\,(\mathbf0,\,u)\},
  \]
  as illustrated by the corresponding exploded graph edges:
    \begin{center}
    \tikzstyle{n}=[fill=black,circle,inner sep=1.5pt]
\begin{tikzpicture}[>=stealth,on grid, auto]
    \node [n,label=$\mathbf{0}$] (zero){};
    \node [n] (zero_) [below=\edge of zero] {};
    \node [n,label=$u$] (u) [right=\nd of zero] {};
    \node [n] (u_) [below=\edge of u] {};
    \node [n,label=$v$] (v) [right=\nd of u] {};
    \node [n] (v_) [below=\edge of v] {};
    \node [n,label=$w$] (w) [right=\nd of v] {};
    \node [n] (w_) [below=\edge of w] {};
    \node [n] (zero__) [below=\edge of zero_] {};
    \node [n] (u__) [below=\edge of u_] {};
    \node [n] (v__) [below=\edge of v_] {};
    \node [n] (w__) [below=\edge of w_] {};

    \path[->](zero) edge node[left] {$R_f$} (zero_);
    \path[->](zero) edge (u_);
    \path[->](w) edge (w_);
    \path[->](zero_) edge node[left] {$R_g$} (zero__);
    \path[->](u_) edge (u__);
    \path[->](v_) edge (v__);
    
    \node [n,label=$\mathbf{0}$] (zeroC) [below right= .5\edge and 3.5\dist of w] {};
    \node [n] (zeroC_) [below=\edge of zeroC] {};
    \node [n,label=$u$] (uC) [right=\nd of zeroC] {};
    \node [n] (uC_) [below=\edge of uC] {};
    \node [n,label=$v$] (vC) [right=\nd of uC] {};
    \node [n] (vC_) [below=\edge of vC] {};
    \node [n,label=$w$] (wC) [right=\nd of vC] {};
    \node [n] (wC_) [below=\edge of wC] {};

    \path[->](zeroC) edge node[left] {$R_f\circ R_g$} (zeroC_);
    \path[->](zeroC) edge (uC_);
  \end{tikzpicture}
  \end{center}
\end{example}

To convert a representation relation $R_f$ back into the original flow function $f$, we can use the \textit{interpretation} function $\denote {R_f}$:
\begin{align}
  f&=\denote{R_f}\notag\\
  &=\lambda D_1\,.\,\left(\left\{d_2\ |\ \exists d_1\in D_1:\,(d_1,\,d_2)\in R_f\right\}\cup\{d_2\ |\ (\mathbf0,\,d_2)\in R_f\}\right)
  \setminus\{\mathbf0\}\,.
\end{align}

We presented an overview of the IFDS analysis. IFDS problems are transformed into IDE problems by the correlated-calls analysis. The IDE analysis is described in the next section.

\subsection{IDE}\label{sec:bgide}
There exists an entire class of data-flow problems that cannot be formulated as IFDS problems. Informally, the problems cannot be formulated as decision problems. For instance, a constant-propagation problem asks, for each variable $v$ in the program, ``if $v$ is a constant at a given program point, what is $v$'s value?''.
The questions asked by constant propagation are of the form ``if property $X$ \textit{($v$ being a constant)} is true at program point~$Y$, what is the value of some property~$Z$ \textit{(the value of the constant)} corresponding to~$X$?''. It turns out that problems with such questions can often be solved by the IDE algorithm.

Instead of just telling us whether a fact holds or not, the IDE analysis can provide us with additional information about facts. 

Just as in the IFDS analysis, the IDE algorithm reduces a data-flow problem to a graph-reachability problem. Additionally, for each program point, the algorithm computes an \textit{environment} $\textsf{Env}(D,\,L)$, where data-flow facts are mapped to values of a lattice $L$.

For example, using the IDE analysis, we can encode a restricted version of a constant-propagation analysis\footnote{%
  In the general case, constant propagation cannot be encoded with distributive flow functions and is therefore not suitable for an IDE analysis~\cite{muller2001complexity}.
}. The data-flow facts  correspond to program variables, and the lattice incorporates all possible values for constants. 
If a fact $d$ in the exploded supergraph is reachable at node $n$, and $\textsf{Env}(d)\notin\{\bot,\,\top\}$, it means that the variable associated with $d$ is a constant. Furthermore, the value of the constant can be inferred from the environment for the corresponding node and is equal to $\textsf{Env}(d)$.

Formally, an IDE problem is defined as a four-tuple
\begin{equation}
  (G^*,\,D,\,L,\,M_\textsf{Env})\,,
\end{equation}
where $G^*$ is a control-flow supergraph, $D$ is a set of data-flow facts, and $L$ is a meet semilattice
with finite height. 
Finally, $M_\textsf{Env}:\,E^*\to(\textsf{Env}(D,\,L)\to \textsf{Env}(D,\,L))$ is a function from the edges of the control-flow supergraph to distributive \textit{environment transformers}. $M_\textsf{Env}$ is extended to paths by composition.

Given an IDE problem, for each node $n\in N^*$ and fact $d\in D$, the IDE algorithm computes the meet-over-all-valid-paths solution
\begin{equation}\label{eq:mvpdef}
  \mvp{\textsf{Env}}(n,\,d)=\bigsqcap_{q\in\ivp(n)}M_\textsf{Env}(q)(\Omega)(d)\,,
\end{equation}
where $M_\textsf{Env}$ is extended to paths by composition and
\begin{equation}
  \Omega=\lambda d\,.\,\top
\end{equation}
is the top element in the environment lattice~$\mathsf{Env}(D,\,L)$.

The IDE analysis is a generalization of the IFDS analysis: every IFDS problem can be converted into an equivalent IDE problem~\cite{reps1995precise}. The equivalent problem can be solved by the IDE algorithm, and the result converted into an IFDS result. In~an~IFDS-equivalent IDE problem, the~graph~$G^*$ and the~set~$D$ of~data-flow facts remain the~same. The $L$ lattice is a two-point lattice: if a fact is mapped to the top (bottom) element, then it is reachable (unreachable). The conversion between IFDS and IDE problems is discussed in detail in Section~\ref{seq:transIfdsIde}.

\subsubsection{Environment Transformers}
For each node in the control-flow graph, the result of an IDE analysis computes an environment $\textsf{Env}(D,\,L)$, which is a map from data-flow facts to lattice elements.

Instead of flow functions that show how to propagate facts, the IDE framework uses distributive environment transformers to propagate environments. For each edge $(n_1,\,n_2)$ in the control-flow supergraph, an environment transformer indicates how the environment at node $n_1$ is modified at node $n_2$.

From Section~\ref{sec:overviewifds} we know that flow functions can be represented with exploded-graph edges. To represent environment transformers, we will construct \textit{labeled} exploded-graph edges, where each edge is associated with a distributive \textit{micro function}%
\footnote{See~Sagiv et al.~\cite{sagiv1996precise} for a formal definition of the representation relation for environment transformers.}
$f:\,L\to L$. A~micro function shows how to change a lattice element for a given node and fact.

If an IDE problem is equivalent to an IFDS problem, the edges of the exploded supergraph are the same for both problems. In the IDE problem, the edges of the exploded supergraph are labeled with identity micro functions.

We extend the meet operator to work on micro functions by defining
\begin{equation}
  (f_1\sqcap f_2)(l)=f_1(l)\sqcap f_2(l)
\end{equation}
for all $l\in L$.

In IDE problems, the auxiliary fact analogous to $\mathbf0$ in IFDS is denoted as $\Lambda$.

\begin{example}\label{ex:constprop}
  One version of the constant propagation analysis that can be encoded with IDE is \textit{linear constant propagation}. A linear constant propagation analysis can detect constants of the form $a\cdot x+b$, where $a$ and $b$ are integers and $x$ is a variable. In particular, a variable can only be considered constant if it depends on at most one other constant variable: even if $y$ and $z$ are variables that are considered constant, the variable $x=y+z$ will be considered not constant. If we encoded the analysis in a way to handle non-linear constant assignments, we would have to use non-distributive flow functions, which would violate the requirements of the IDE algorithm.

  For linear constant propagation, the $L$ lattice consists of the set of integers $\mathbb Z$, a top element denoting ``not a constant'', and a bottom element denoting an unknown value.
  The meet of two lattice elements is defined as follows: for any lattice element $l\in L$,
  \[
    \top\sqcap l=\top\qquad\text{and}\qquad\bot\sqcap l=l.
  \]
  For two lattice elements $l_1,\,l_2\in\mathbb Z$, $$l_1\sqcap l_2=\top.$$
  
  We define the addition and multiplication operations on lattice elements $l\in L$ and integers $c\in\mathbb Z$ as follows:
  \[
    l+c=\begin{cases}
      \bot&\text{if }l=\bot;\\
      \top&\text{if }l=\top;\\
      l+c&\text{otherwise.}
    \end{cases}
    \qquad
    c\cdot l=\begin{cases}
      \bot&\text{if }l=\bot;\\
      \top&\text{if }l=\top;\\
      c\cdot l&\text{otherwise.}
    \end{cases}
  \]
   Let the function $M$ that maps supergraph edges to environment transformers be defined in the following way:
  \[
    M=\lambda((n_1,\,n_2))\,.\,
    \begin{cases}
      \lambda\textsf{env}\,.\,\textsf{env}[x\to a\cdot\textsf{env}(y)+c\,]
        &\text{if $n_1$ contains an assignment}\\&\text{$x=a\cdot y+c$, where $y$ is a variable}\\&\text{and $a,\,c$ are constants;}\\
      \id
        &\text{otherwise.}
    \end{cases}
  \]
  Here, we denote with $\textsf{env}[x\to a]$ an environment \textsf{env} in which the key $x$ is mapped to $a$, and all other keys $y\ne x$ are mapped to their old values $\textsf{env}(y)$.
  When $M$ is applied to an edge whose source node contains an assignment for a variable $x$, $M$ returns an environment transformer that updates the argument environment with a new value for $x$. 

  Consider the following program:

\inputMinted{java}{constprop.java}
  For the edges $e_1,\,e_2,\,e_3$, and $e_4$ that start at the first, second, third, and fourth instruction, $M$ creates the following environment transformers:
  \begin{align*}
    M(e_1)
    &=\lambda\textsf{env}\,.\,\textsf{env}[\texttt u\to 1]\\
    M(e_2)
    &=\lambda\textsf{env}\,.\,\textsf{env}[\texttt v\to\textsf{env}(\texttt u)+2]\\
    M(e_3)
    &=\lambda\textsf{env}\,.\,\textsf{env}[\texttt w\to\top]\\
    M(e_4)
    &=\lambda\textsf{env}\,.\,\textsf{env}[\texttt u\to 5].
  \end{align*}
  
  The corresponding labeled exploded supergraph is shown in Figure~\ref{fig:constprop}.
  
  The result of the analysis yields a map from nodes to environments. Each environment maps variables to elements of the constant-propagation lattice. The environment at the last node will look as follows:
  \[
    \{(\texttt u,\,5),\ (\texttt v,\,3),\ (\texttt w,\,\top)\}.
  \]
\end{example}
\begin{figure}
  \centering
    \tikzstyle{n}=[fill=black,circle,inner sep=1.5pt,sm]
    \tikzstyle{sm}=[font=\footnotesize]
\begin{tikzpicture}[>=stealth,on grid, auto]
    \node [n,label=$\Lambda$] (zero){};
    \node [n] (zero_) [below=\edge of zero] {};
    \node [n,label={\texttt u}] (u) [right=\dist of zero] {};
    \node [n] (u_) [below=\edge of u] {};
    \node [n,label={\texttt v}] (v) [right=\dist of u] {};
    \node [n] (v_) [below=\edge of v] {};
    \node [n,label=\texttt{w}] (w) [right=\dist of v] {};
    \node [n] (w_) [below=\edge of w] {};
    \node [n] (zero__) [below=\edge of zero_]{};
    \node [n] (u__) [below=\edge of u_]{};
    \node [n] (v__) [below=\edge of v_]{};
    \node [n] (w__) [below=\edge of w_]{};
    \node [n] (zero___) [below=\edge of zero__]{};
    \node [n] (u___) [below=\edge of u__]{};
    \node [n] (v___) [below=\edge of v__)]{};
    \node [n] (w___) [below=\edge of w__]{};  
    \node [n] (zero____) [below=\edge of zero___]{};
    \node [n] (u____) [below=\edge of u___]{};
    \node [n] (v____) [below=\edge of v___)]{};
    \node [n] (w____) [below=\edge of w___]{};     
    
    \path[->](zero) edge node[left,sm]{$\id$} (zero_);
    \path[->](zero) edge node[right,sm]{$\lambda l.1$} (u_);
    \path[->](zero_) edge node[left,sm]{$\id$} (zero__);
    \path[->](u_) edge node[right,sm]{$\lambda l.l+2$} (v__);
    \path[->](u_) edge node[left,sm]{$\id$} (u__);
    \path[->](zero__) edge node[left,sm]{$\id$} (zero___);
    \path[->](u__) edge node[left,sm]{$\id$} (u___);
    \path[->](v__) edge node[left,sm]{$\id$} (v___);
    
    \path[->,dashed,color=gray](v) edge node[left,sm]{$\id$} (v_);
    \path[->,dashed,color=gray](w) edge node[left,sm]{$\id$} (w_);
    \path[->,dashed,color=gray](w_) edge node[right,sm]{$\id$} (w__);
    
    \path[->] (zero___) edge node[left,sm]{$\id$} (zero____);
    \path[->] (u___) edge node[left,sm]{$\lambda l.5$} (u____);
    \path[->] (v___) edge node[left,sm]{$\id$} (v____);
    \path[->,dashed,color=gray] (w___) edge node[left,sm]{$\id$} (w____);
  \end{tikzpicture}
  \caption[A labeled exploded supergraph for a constant-propagation analysis described in Example~\ref{ex:constprop}]{A labeled exploded supergraph for a constant-propagation analysis described in Example~\ref{ex:constprop}. The dashed edges are edges not reachable from the entry node.}%
  \label{fig:constprop}%
  \end{figure}
  
In this way, each edge in the exploded graph is labeled with a micro function. The mapping from exploded-graph edges to the corresponding micro functions is stored in \textit{edge functions},  denoted as \textsf{EdgeFn}$:\,E^\#\to(L\to L)$.

\subsubsection{Overview of the IDE Algorithm}\label{sec:ideoverview}
Given a labeled exploded supergraph, the IDE algorithm computes the environments for all nodes in the control-flow graph.

The algorithm first computes the lattice elements $l_{n,\,d}$ that correspond to each reachable node $(n,\,d)$ in the exploded supergraph. The union of the exploded nodes $(n,\,d)$ for a given control-flow node $n$, mapped to the corresponding lattice elements $l_{n,\,d}$, form the environment $\textsf{Env}_n$  for that node:
\begin{equation}
  \textsf{Env}_n=\left\{(d,\,l_{n,\,d})\ |\ (n,\,d)\in N^\#\right\}\,.
\end{equation}

The overall idea behind computing the lattice elements $l_{n,\,d}$ is the following. For each inter-procedurally realizable path
\[
  p=\left[(\startmain,\,\Lambda),\,(n_1,\,d_1),\,\dots,\,(n_k,\,d_k)\right]
\]
 that starts with the entrypoint of the exploded supergraph, we compute the function $f_p$ that corresponds to $p$. The micro function consists of the composition of all individual micro functions with which the edges of $p$ are labeled:
\begin{align}
  f_p=\textsf{EdgeFn}((n_{k-1},\,d_{k-1}),\,(n_k,\,d_k))\,\circ\ldots\circ
      \textsf{EdgeFn}(\startmain,\,\Lambda),\,(n_1,\,d_1))\,.
\end{align}

Let the lattice element that $(n,\,d)$ is mapped to according to path $p$ be denoted as $l_{n,\,d}^p$. As shown in~Sagiv et al.~\cite{sagiv1996precise}, the lattice element can be obtained by applying $f_p$ to the bottom element:
\begin{equation}
 l^p_{n,\,d}=f_p(\bot)\,.
\end{equation}

Let $Q$ be the set of paths that start at the entry point and end at the given node $(n,\,d)$.

The lattice element $l_{n,\,d}$ is the meet of the lattice elements corresponding to all the paths in $Q$:
\[
  l_{n,\,d}=\bigsqcap_{q\in Q}l^q_{n,\,d}\,.
\]

This is a general outline of the IDE analysis. We use the IDE framework to improve the precision of IFDS problems in the presence of correlated calls.
The next section describes how this is done.
