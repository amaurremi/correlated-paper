%\subsection{Implementation of the Correlated-Calls Analysis}
\section{Evaluation}
  \label{sec:Evaluation}

We implemented the correlated-calls analysis in Scala~\cite{odersky2004overview}. 
Our implementation analyzes JVM bytecode compiled from input programs written
in Java.
%The input programs that we analyzed were written in Java. Our implementation analyzed the
%corresponding Java bytecode.
We use WALA~\cite{fink2012wala}
to retrieve information about an input program, such as its control-flow supergraph and the set of receivers and their types.
Since WALA does not contain an implementation of the IDE algorithm,
we implemented it from scratch.
%currently only contains an implementation of IFDS, we implemented IDE from scratch.
We will submit our implementation to the artifact evaluation committee, and we are working on integrating it and contributing it officially to WALA. % Instead of using WALA's IFDS implementation, to run an IFDS problem, we converted it to an IDE problem and used our own IDE solver.

We tested the implementation of the correlated-calls analysis using an IFDS taint-analysis implementation as a client analysis. We converted the IFDS taint analysis into an IDE problem with an implementation of $\transCC_\rcc$.

We extensively tested the correlated-calls analysis to ensure that in the absence of correlated calls in an input program, the analysis produced the same results as an IFDS-equivalent analysis, and in the presence of correlated calls, the result was more precise.

The average running time for small programs such as in Figure~\ref{list:ccexample} is ???~seconds. On the SPECjvm98 benchmarks, the average running time is ???~seconds. So far we were only able to find a practical benefit from the correlated-calls analysis for programs in which correlated calls were ``artificially'' introduced in control-flow paths relevant to the specific client analysis. We are still working on identifying in which client IFDS problems, in combination with which benchmarks, we would encounter a precision improvement.

\commentout{
The artifact of our implementation can be used to solve any IFDS problem. In the presence of correlated calls, the result of the correlated-calls analysis can be more precise than the result obtained with an IFDS solver.
}