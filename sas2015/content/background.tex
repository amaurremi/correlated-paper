\section{Background}\label{sec:bg}
%The purpose of the correlated-calls analysis is to solve IFDS problems more precisely than using the standard IFDS algorithm by ruling out some infeasible paths. The correlated-calls analysis works by transforming an IFDS problem to an IDE problem, solving the IDE problem, and transforming the IDE result to a solution to the original IFDS problem. 
This section defines basic terminology and presents the IFDS and IDE algorithms.
%\ftodo{
  %Shall we add a sentence saying that readers familiar with these algorithms may skip this section?
%}

\subsection{Terminology and Notation}
%We will start by introducing several concepts used by the IFDS and IDE analyses.
%\begin{mdelete}\mtodo{We already say (but less precisely) what a CFG is in the introduction.}
The \textit{control-flow graph} of a procedure is a directed graph whose nodes are instructions, which contains an edge from $n_1$ to $n_2$ whenever
$n_2$ may execute immediately after $n_1$. A CFG has a distinguished \textit{start node} \textsf{start}$_p$ and \textit{end node} \textsf{end}$_p$.
Following the presentation of Reps~et~al.~\cite{reps1995precise,sagiv1996precise}, we follow every
call instruction with a no-op instruction, so that every \textit{call node} is immediately
followed by a \textit{return node} in the CFG.
%\end{mdelete}
%and edges represent transfer of control between the instructions during an execution of the program. 
%A control-flow graph has a unique start node, $\startmain$, which is the node corresponding to the program entrypoint.
%An \textit{intraprocedural} path is a path in a control-flow graph whose nodes are in the same procedure. By contrast, an \textit{interprocedural path} is one that contains nodes from different procedures. 
The \textit{control-flow supergraph} of a program contains the CFGs of all of the procedures as
subgraphs. In addition, for each call instruction $c$, the supergraph contains a \textit{call-to-start} edge to the start node of every procedure that
may be called from $c$, and an \textit{end-to-return} edge from the end node of the procedure back to the call instruction.
%\otodo{do we really need to extra "return nodes" that the IFDS/IDE papers add?}
%is a control-flow graph
%in which each procedure $p$ is augmented with an additional \textit{start node} \textsf{start}$_p$ and \textit{end node} \textsf{end}$_p$, and for each call $c_q$ to a procedure $q$, there is a \textit{call node} \textsf{call}$_{c_q}$ and subsequent \textit{return node} \textsf{return}$_{c_q}$.

%A control-flow supergraph allows us to model the control flow in interprocedural paths.
 %The flow from the caller to the callee is represented using an edge \[(\textsf{call}_{c_q},\,\textsf{start}_q)\,.\] The control flow from the callee back to the caller goes through an edge \[(\textsf{end}_q,\,\textsf{return}_{c_q})\,.\]

A call site is \textit{monomorphic} if it always calls the same procedure. In an object-oriented language, 
a call site $r.m(\ldots)$ can dynamically dispatch to multiple methods depending on the runtime
type of the object pointed to by the receiver $r$.
A call site that calls multiple procedures is called
\textit{polymorphic}.
We define a function $\textsf{lookup}$ to specify the dynamic dispatch: 
if $s$ is the signature of $m$ and $t$ is the runtime type of the object
pointed to by $r$, $\textsf{lookup}(s,t)$ gives the procedure that will
be invoked by the call $r.m(\ldots)$. We also define a function $\tau$
that may be viewed as the inverse
of $\textsf{lookup}$: given a signature $s$ and a specific invoked procedure
$f$, $\tau(s,f)$ gives the set of all runtime types of $r$ that cause $r.m(\ldots)$
to dispatch to $f$: $\tau(s,f) = \{t\mid \textsf{lookup}(s,t)=f\}$.

%\otodo{do we ever use $\src$ and $\target$?}
%We denote the source and end nodes of a graph edge $e$ as $\src e$ and $\target e$.

%A \textit{flow-sensitive} data-flow analysis is one that takes the order of program instructions into account.

A path in the control-flow supergraph is \textit{valid} if it follows the usual stack-based calling 
discipline: every end-to-return edge on the path returns
to the site of the most recent call that has not yet been matched by a return. 
%\ftodo{Can we explain/define the notion of the ``most recent unmatched call'' more precisely?}
The set of all valid paths from the program entry point to
a node $n$ is denoted $\ivp(n)$.
%\otodo{Should we give a formal definition?}

%Let each call node in a program be labeled with a distinct opening parenthesis and the corresponding return node with the matching closing parenthesis. For a given path $p$, let $s$ be the string that is obtained by concatenating the labels of the nodes in $p$.
%Then $p$ is \textit{valid} if $s$ belongs to the language of substrings of balanced parentheses. The set of all interprocedurally valid paths from the start node to a node $n$ is denoted as $\ivp(n)$. The set $\ivp(n)$ is a conservative approximation of all concrete execution paths from the start node to $n$.

%A \textit{context-sensitive} data-flow analysis is an analysis that considers only interprocedurally valid paths.

\commentout{
\begin{mdelete}
\begin{example}
  In the supergraph in Figure~\ref{fig:examplesupergraph}, let us assign $\{,\,\}$ parentheses to $\textsf{call}_\texttt{A.f}$ and $\textsf{return}_\texttt{A.f}$, and $\langle,\,\rangle$ parentheses to $\textsf{call}_\texttt{f}$ and $\textsf{return}_\texttt{f}$. 
  Then the string corresponding to the path 
  \[
    p_1=\left[\highlight{\textsf{call}_\texttt{A.f}}{greyblue},\,
          \highlight{\textsf{start}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\texttt{if (s == null)}}{lightsalmonpink},\,
          \highlight{\texttt{return s}}{lightsalmonpink},\,
          \highlight{\textsf{end}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\textsf{return}_\texttt{A.f}}{greyblue}
    \right]
  \]
  is $\{\}$, which indicates that $p_1$ is valid. Every prefix of $p_1$ is also a valid path.
    
However, the graph also contains an interprocedurally invalid path
  \[
    p_2=\left[\highlight{\textsf{call}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\textsf{start}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\texttt{if (s == null)}}{lightsalmonpink},\,
          \highlight{\texttt{return s}}{lightsalmonpink},\,
          \highlight{\textsf{end}_\texttt{f}}{lightsalmonpink},\,
          \highlight{\textsf{return}_\texttt{A.f}}{greyblue}
    \right]
  \]
  with corresponding string $\langle\}$.
\end{example}
\end{mdelete}
}

%\otodo{The definitions that Marianna had were for \emph{complete}
%lattices/semilattices. All of the lattices in the context of IFDS/IDE
%are/must be complete. I'll just say that here.}
%\ftodo{Would it make sense to first the define the notion of a lattice without referring to its completeness?
       %This could be followed by defining what it means for a (semi)lattice to be complete, and then we
       %could say that all lattices considered in this paper are complete, etc.}
%\ftodo{Can we define the symbols $\sqcup$ and $\sqcap$ for join and meet here?}
A \textit{lattice}%
\footnote{The definitions that we give here are of \textit{complete} lattices and semilattices.
Since all of the (semi)lattices discussed in this paper are required to be complete, we omit the
\textit{complete} qualifier.}
is a partially ordered set $(S,\sqsubseteq)$ in which every subset has a least upper bound, called \textit{join} or $\sqcup$, and a greatest lower bound, called \textit{meet} or $\sqcap$.
A \textit{meet semilattice} is a partially ordered set in which every subset only has a greatest lower bound.
The symbols $\bot$ and $\top$ are used to denote the greatest lower bound of $S$ and of the empty set, respectively.


%A \textit{meet semilattice} $L=(S,\,\sqcap)$ is defined by a set $S$ and a meet operation $\sqcap$ that is  associative, commutative, and idempotent.
  %The meet operation induces a partial order $(S,\,\sqsubseteq)$ where every subset contains  a greatest lower bound: For all $x,\,y\in S$, $x\sqsubseteq y$ if $x\sqcap y=x$. The greatest lower bound, or top element, of the semilattice is denoted as $\top$.
  %If $k$ is the length of the longest chains of elements in the semilattice, then the \textit{height} of the semilattice is~$k-1$.

In this paper, we denote a map $m$ as a set of pairs of keys and values, in which each key appears at most once.
For any map $m$,  $m(k)$ is the value paired with the key $k$ in $m$. We denote by $m[x\to y]$ a map that maps $x$ to $y$, and every other key $k$ to $m(k)$.
%To avoid excessive parentheses, we write $\left(m[x_1\to y_1]\right)[x_2\to y_2]$ as $m[x_1\to y_1][x_2\to y_2]$.

%We will denote the identity function $\lambda x\,.x$ by $\textsf{id}$.
%We will use a typed version of this function in various contexts, where the type of $x$ will vary with
%the context.

%OL: we can just as easily write the identity explicitly as \x.x throughout.

\subsection{IFDS}\label{sec:bgifds}
The IFDS framework~\cite{reps1995precise} is a precise and efficient algorithm for data-flow analysis
%. IFDS was developed in 1995 by T.\,Reps, S.\,Horwitz, and M.\,Sagiv at the University of Wisconsin and
that has been used to solve a variety of data-flow analysis problems~\cite{bodden2013spl,naeem2008typestate,DBLP:conf/birthday/KreikerRRSWY13,tripp2009taj}.
%\mtodo{ The four references take away space in the References section. Remove some of them?  }
The IFDS framework is an instance of the \textit{functional approach} to data-flow analysis~\cite{pnueli1981two}
because it constructs summaries of the effects of called procedures.
\commentout{The IFDS analysis is a version of the classic \textit{functional approach} to data-flow analysis proposed by M.\,Sharir and A.\,Pnueli~\cite{pnueli1981two}.}
\commentout{In other data-flow algorithms not based on the functional approach, the result of the analysis at the entry of a procedure ``merges'' the incoming data obtained from all callers of the procedure. As a consequence, there is one global data-flow result computed at the end of the procedure. Context-sensitivity, however, allows an analysis to compute the data-flow result for a given procedure as a \textit{function} of the data-flow value at the start of the procedure. 
The analysis result for a procedure varies depending on where the procedure was called from. This significantly improves the precision of a data-flow analysis, which is why context-sensitivity is an important advantage of IFDS over classic data-flow algorithms.}
The IFDS framework is applicable to \textit{interprocedural} data-flow problems whose domain is \textit{subsets} of a \textit{finite} set $D$,
and whose data-flow functions are \textit{distributive}.
A function $f$ is distributive if 
$f(x_1\sqcap x_2)=f(x_1)\sqcap f(x_2)$.

%The IFDS algorithm is applicable to problems which can be expressed with data-flow functions that satisfy certain restrictions. \textit{Interprocedural} flow functions specify how data flows from the invocation of a procedure to its start, and from the procedure's end back to its call site. \textit{Distributive} flow functions are those that distribute over the confluence operator. In the context of IFDS, the confluence operator is called meet, and it can be either union or intersection. The data-flow facts on which the analysis operates must be a \textit{finite} set $D$. Each flow function operates on a \textit{subset} of $D$ (for example, the set of variables in the program) which makes the domain of the flow functions the power set of $D$.

\commentout{The purpose of the IFDS framework is to solve a special subset of interprocedural, flow-sensitive, context-sensitive data-flow-analysis problems. The main idea of IFDS is to encode the data-flow analysis problem into a graph-reachability problem.}

The IFDS algorithm is notable because it computes a meet-over-valid paths solution in polynomial time.
Most other interprocedural analysis algorithms are either: 
  (i) imprecise due to invalid paths,
  (ii) general but do not run in polynomial time~\cite{knoop1992interprocedural,pnueli1981two}, or 
  (iii) handle a very specific set of problems~\cite{knoop1993efficient}.

%\subsubsection{Data-Flow Problems Suitable for IFDS}\label{sec:suitableifds}
\commentout{In this section we describe the data-flow problems that can be solved by an IFDS analysis. We will start with an intuitive definition and later on formalize the notion of an IFDS-suitable problem.}

%Informally, an IFDS analysis can only solve decision problems. An IFDS analysis answers questions of the following kind: ``is property $X$ true at program point~$Y$?''. For example, a taint-analysis problem asks, for each variable $v$ in the program, ``is $v$ secret at a given program point?''. 
\commentout{An available-expressions problem asks, for each expression $e$, ``does $e$ have to be recomputed at a given program point?''.}

The input to the IFDS algorithm is specified as
%Formally, a data-flow analysis problem is suitable for an IFDS analysis if it can be encoded as an IFDS problem
  $(G^*,\,D,\,F,\,M_F,\,\sqcap)$,
where $G^*=(N^*,\,E^*)$ is the supergraph of the input program with nodes $N^*$ and edges $E^*$,
$D$ is a finite set of \textit{data-flow facts},
$F$ is a set of distributive data-flow functions of type $2^D\to2^D$,
$M_F:\,E^*\to F$ assigns a data-flow function to each supergraph edge,
and $\sqcap$ is the \textit{meet operator} on the powerset $2^D$, either union or intersection.
In our presentation, the meet operator will always be union, but all of the results apply dually when the
meet is intersection.

The output of the IFDS algorithm is, for each node $n$ in the supergraph, the \textit{meet-over-all-valid-paths} solution
 $\mvp{F}(n)=\bigsqcap_{q\in\ivp(n)}M_F(q)(\top)$, where $M_F$ is extended from edges to paths by composition.

\commentout{
is a function that maps supergraph edges to data-flow functions, and $M_F$ is extended to paths by composition\footnote{%
  Let $A$ be a set and $f:\,E^*\to(A\to A)$ a function from supergraph edges to functions on $A$.
  We say that $f$ is extended to  paths by composition to denote that for a path $q$ consisting of the edges $e_1,\,\dots,\,e_k$, $f(q)=f(e_k)\circ\ldots\circ f(e_1)\circ\id$.
}. The \textit{meet operator} $\sqcap$ is either union or intersection.
}

%Without loss of generality, we will take meet to denote union. It can be shown that any problem where meet is defined as intersection can be reformulated into an equivalent one where meet is defined as union~\cite{reps1995precise}.

\subsubsection{Overview of the IFDS Algorithm}\label{sec:overviewifds}
The key idea behind the IFDS algorithm is that it is possible to represent any distributive
function $f$ from $2^D$ to $2^D$ by a \textit{representation relation} $R_f \subseteq 
(D \cup \{0\})
\times
(D \cup \{0\})$. The representation relation can be visualized as a bipartite graph
with edges from one instance of $D \cup \{0\}$ to another instance of $D \cup \{0\}$.
The IFDS algorithm uses such graphs to efficiently represent both the input data-flow functions
and the summary functions that it computes for called procedures.
Specifically, the representation relation $R_f$ of a function $f$ is defined as:
\[
R_f=\{(\mathbf0,\,\mathbf0)\}\cup
      \{(\mathbf0,\,d_j)\,|\,d_j\in f(\varnothing)\}\cup
      \{(d_i,\,d_j)\,|\,d_j\in f(\{d_i\}) \setminus f(\varnothing)\}.
\]
\begin{floatingfigure}[lrp]{3.5cm}
\input{figures/ex1minigraph} 
\end{floatingfigure}
\begin{example}\label{ex:flowfun}
Given $D=\{u,\,v,\,w\}$ and $f(S) = S\setminus\{v\} \cup \{u\}$,
    the representation
 relation 
  $
    R_f=\{(\mathbf0,\,\mathbf0),\,(\mathbf0,\,u),\,(w,\,w)\}
$, which is depicted on the graph below.
\end{example}

The representation relation decomposes a flow function into functions
(edges) that operate on each fact individually. This is possible due
to distributivity: applying the flow function to a set of facts is
equivalent to applying it on each fact individually and then
taking the union of the results.

The meet of two functions can be computed as simply the union of their representation
functions: $R_{f\sqcap f'} = R_f \cup R_{f'}$. The composition of two functions can be
computed by combining their representation graphs, merging the range nodes of the
first function with the corresponding domain nodes of the second function, and finding
paths in the resulting graph.

\commentout{
The representation relation allows us to compactly represent the composition and meet operations which are required for the IFDS algorithm.

For two representation relations $R_{f_1},\,R_{f_2}$, the composition and meet operations are defined as follows:
\begin{align}
  R_{f_1}\circ R_{f_2}&=\{(d_1,\,d_3)\ |\ \exists d_2:\ (d_1,\,d_2)\in R_{f_1},\,(d_2,\,d_3)\in R_{f_2}\}\,.
\intertext{and}
  R_{f_1}\sqcap R_{f_2}&=R_{f_1}\cup R_{f_2}\,.
\end{align}

The representation relation distributes over composition and meet:
\begin{align}
  R_{f_1}\circ R_{f_2}=R_{f_1\circ f_2}\,,\qquad
\text{and}\qquad
  R_{f_1}\sqcap R_{f_2}=R_{f_1\sqcap f_2}\,.
\end{align}
}

%On the exploded graph, the composition of two functions is represented by the paths that are formed when the exploded-graph edges are combined.
%\otodo{The example used to say $R_f \circ R_g$, but I believe it showed $R_g \circ R_f$. I fixed it, but please check that this is correct.}

\begin{example}
    If $g(S)=S\setminus\{w\}$ and $f(S) = S\setminus\{v\} \cup \{u\}$, then
    $
    R_g\circ R_f=\{(\mathbf0,\,\mathbf0),\,(\mathbf0,\,u)\},
    $
  as illustrated in the graphs below.
\begin{floatingfigure}[lrp]{3.5cm}
  \input{figures/ex2minigraph}
\end{floatingfigure}
\end{example}

Composition of two distributive
functions $f$ and $f'$ corresponds to finding reachable nodes in a graph composed from their representation
relations $R_f$ and $R_{f'}$. Therefore, evaluating the composed data-flow function for a control
flow path corresponds to finding reachable nodes in a graph composed from the representation relations
of the data-flow functions for individual instructions.

It is this graph of representation relations that the IFDS algorithm operates on.
In this graph, called the \textit{exploded supergraph}, each node is a pair $(n,d)$, where
$n\in N^*$ is a node of the control-flow supergraph and $d$ is an element of $D\cup\{0\}$.
For each edge $(n \to n') \in E^*$, the exploded supergraph contains a set of edges
$(n,d_i) \to (n',d_j)$, which form the representation relation of the data-flow function
$M_F(n \to n')$. The IFDS algorithm finds all exploded supergraph edges that are reachable by
\textit{realizable} paths in the exploded supergraph. A path
is \textit{realizable} if its projection to the (non-exploded) supergraph is a valid
path (i.e., if it is of the form $(n_0, d_0) \to (n_1,d_1) \to \cdots \to (n_m,d_m)$
and where $n_0 \to n_1 \to \cdots \to n_m$ is a valid path).

\begin{example}
  The exploded supergraph for Listing~\ref{list:ccexample} is shown in Figure~\ref{fig:cc_edgefn_example}.
  The labels on the edges will be explained in Section~\ref{sec:bgide}
  We can see that there is a realizable path, highlighted in bold,
  from the start node of the exploded graph to the variable \verb's' at~the~node~$\textsf{print(s)}$ in the \verb'B.bar' method. This means that \verb's' is considered secret at that node.
\end{example}

\subsection{IDE}\label{sec:bgide}

The IDE algorithm~\cite{sagiv1996precise} extends IFDS to
\textit{interprocedural} \textit{distributive} \textit{environment}
problems. An \textit{environment} problem is an analysis whose data-flow
lattice is the lattice $\textsf{Env}(D,L)$ of maps from a finite set $D$ to a meet semilattice
$L$ of finite height, ordered pointwise. Like IFDS, IDE requires the data-flow functions to be distributive.

The input to the IDE algorithm is
  $(G^*,\,D,\,L,\,M_\textsf{Env})$
where $G^*$ is a control-flow supergraph,
$D$ is a set of data-flow facts,
$L$ is a meet semilattice of finite height,
and $M_\textsf{Env}:\,E^*\to(\textsf{Env}(D,\,L)\to \textsf{Env}(D,\,L))$ assigns a data-flow function
to each supergraph edge.

The output of the IDE algorithm is, for each node $n$ in the supergraph,
the \textit{meet-over-all-valid-paths} solution
$\mvp{\textsf{Env}}(n)=\bigsqcap_{q\in\ivp(n)}M_\textsf{Env}(q)(\top_\textsf{Env})$,
%\mtodo{Should it be $\Omega$ instead of $\top$?}
where $\top_\textsf{Env} = \lambda d.\top$ is the top element of the lattice of environments,
and $M_\textsf{Env}$ is extended from edges to paths by composition.

\subsubsection{Overview of the IDE Algorithm}\label{sec:ideoverview}
Just as any distributive function from $2^D$ to $2^D$ can be represented with a
representation relation, it is also possible to represent any distributive functions from
$\textsf{Env}(D,L)$
to
$\textsf{Env}(D,L)$
with a \textit{pointwise representation}. A pointwise representation is a bipartite graph
with the same nodes~\footnote{The IDE literature uses the symbol $\Lambda$ for the node that
    is denoted $\mathbf0$ in the IFDS literature. We use $\mathbf0$ throughout this paper for consistency.}
and edges as a representation relation, except that each edge is labelled
with a \textit{micro-function}, which is a function from $L$ to $L$. 

Thanks to distributivity, every environment transformer 
$t : \textsf{Env}(D,L) \to \textsf{Env}(D,L)$
can be decomposed into its effect on $\top_{\textsf{Env}}$ and on a set of environments $\top_{\textsf{Env}}[d_i\to l]$
that map every element to $\top$ except one ($d_i$):
\[
    t(m)(d_j) = \lambda l. t(\top_{\textsf{Env}})(d_j) \sqcap \bigsqcap_{d_i\in D} \lambda l. t(\top_{\textsf{Env}}[d_i\to l])(d_j).
\]
The functions $\lambda l. \cdots$ in this decomposition are the micro-functions that
appear on the edges of the pointwise representation edges from $\mathbf0$ to each $d_j$ and from
each $d_i$ to each $d_j$.%
\footnote{The IDE paper defines a more complicated but equivalent set of micro-functions
that eliminate some duplication of computation.}
The absence of an edge in the pointwise representation from some $d_i$ to some $d_j$ is
equivalent to an edge with micro-function $\lambda l.\top$.

%\otodo{Discuss the micro-functions in the example exploded supergraph in Figure 3.}
\begin{example}
    In the exploded supergraph in Figure~\ref{fig:cc_edgefn_example},
    the micro-functions are shown as labels on the graph edges.
    Every edge without an explicit label has the identity as its
    micro-function. The micro-functions on the three edges from
    the node \verb+return secret()+ to the node $\texttt{end}_\texttt{A.foo}$
    together represent the environment transformer 
    $\lambda e.e[\psi \to \lambda m.\bot \sqcap \lambda m.m]$.

    To eliminate infeasible paths due to correlated calls, we encode the taint
    analysis using environments $\textsf{Env}(D,L)$, where $D$ is the set of
    variables and $L$ is a map from receiver variables to sets of possible
    types. The interpretation of such an environment $e$ is that a given variable
    $v \in D$ may contain a secret value in an exeuction in which the runtime
    types of the objects pointed to be the receiver variables are in the sets
    specified by $e(v)$.
\end{example}

The meet of two environment transformers $t_1, t_2$ can be computed by taking the union of the edges
in their pointwise representations. When the same edge appears in the pointwise representations of
both $t_1$ and $t_2$, the micro-function for that edge in $t_1 \sqcap t_2$ is the meet of the
micro-functions for that same edge in $t_1$ and in $t_2$.

The composition of two environment transformers can be computed by combining their pointwise
representation graphs in the same fashion as IFDS representation relations, and 
computing the composition of the micro-functions appearing along each path in the resulting graph.

The IDE algorithm operates on the same exploded supergraph as the IFDS algorithm
(except that the edges are labelled with micro-functions). For each pair $(n,d)$ of
node and fact, the algorithm computes a micro-function equal to the meet of the micro-functions
of all the realizable paths from the program entry point to the pair.

In order to do this efficiently, the IDE algorithm requires a representation of micro-functions
that is general enough to express the basic micro-functions of the data-flow functions for individual
instructions, and that supports computing the meet and composition of micro-functions.

A practical implementation of the IDE algorithm requires
the input data-flow functions to be provided in their pointwise representation
as exploded supergraph edges labelled with micro-functions.
%\mtodo{Should we cite the ``Practical extensions'' paper here that talks about the on-demand IFDS algorithm?}
Specifically,
the input is generally provided as a function $\textsf{EdgeFn}: (N^* \times D) \times (N^* \times D) \to F$,
where $F$ is the set of representations of micro-functions from $L$ to $L$.
Given an exploded supergraph edge $e=(n,\,d) \to (n',\,d')$,
$\textsf{EdgeFn}((n,\,d),\,(n',\,d'))$ returns the micro-function that appears on the exploded supergraph edge $e$.
%Like in the IFDS algorithm,
In an implementation, it can be convenient to split the function $\textsf{EdgeFn}$ into separate functions that handle the cases when $n\to n'$ is an intraprocedural edge, a call-to-return edge, a call-to-start edge, or an end-to-return edge.
